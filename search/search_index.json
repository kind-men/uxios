{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#an-http-client-that-ispowerful-and-simple","title":"An HTTP Client that ispowerful and simple","text":"<p>Uxios is a Unity C# library inspired by Axios, the popular JavaScript HTTP client. Designed for use with Unity, Uxios provides an intuitive and consistent API for making HTTP requests, mirroring the ease of use and flexibility of Axios within the Unity environment. Built to be a part of the JuniSON Engine, Uxios is particularly optimized for WebGL applications but remains compatible with Android, iOS, and Desktop builds, making it a versatile solution for Unity projects across platforms.</p>"},{"location":"#it-just-works","title":"It just works","text":""},{"location":"#on-all-platforms","title":"On all platforms","text":"<p>Uxios brings effortless HTTP communication to every Unity platform, including WebGL, Android, iOS, and Desktop. Purpose-built for Unity developers, Uxios adapts to your platform\u2019s needs, delivering smooth, reliable data handling whether your project runs on mobile, web, or desktop.</p>"},{"location":"#a-simple-api-for-apis","title":"A Simple API, for API's","text":"<p>Simplify API interactions with Uxios\u2019s <code>Resource</code> wrapper, which provides built-in caching for frequently accessed endpoints, improving efficiency and reducing redundant network calls.</p>"},{"location":"#smart-data-conversion","title":"Smart Data Conversion","text":"<p>Uxios goes beyond standard HTTP requests by automatically converting data between C# objects, sprites, textures, and files. From handling JSON responses to downloading images \u2014as textures\u2014 or files, Uxios takes care of serialization and deserialization seamlessly.</p>"},{"location":"#a-powerful-api-for-complete-control","title":"A Powerful API, for Complete Control","text":"<p>Harness the power of Uxios\u2019s low-level API, inspired by Axios, to manage every detail of your HTTP interactions. With fine-grained control over configuration, headers, and advanced error handling, Uxios lets you shape each request exactly as needed.</p>"},{"location":"#comprehensive-documentation","title":"Comprehensive Documentation","text":"<p>Uxios is backed by extensive, user-friendly documentation, guiding you from setup to advanced usage with clear examples and best practices. Every feature, from basic requests to handling complex error responses, is thoroughly documented to help you get the most out of Uxios.</p>"},{"location":"#freedom-from-monobehaviours-and-coroutines","title":"Freedom from MonoBehaviours and Coroutines","text":"<p>With Uxios, make HTTP requests from any part of your codebase \u2014 no need to rely on MonoBehaviours or Coroutines. Whether you\u2019re handling network requests in a game manager, a data service, or a custom component, Uxios makes it easy to fetch,  send, and manage API calls wherever you need them.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this package will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#041-2025-09-09","title":"[0.4.1] - 2025-09-09","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Missing import statement in QueryString.cs when using a platform other than WebGL</li> </ul>"},{"location":"changelog/#040-2025-07-07","title":"[0.4.0] - 2025-07-07","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>BREAKING: All uses of NameValueCollection are replaced with QueryParameters objects because of excessive garbage    generation. In your code you should check if you use NameValueCollection objects to hold data on query parameters and   change that to QueryParameter instances. This also means that iterating the result of Encode, Decode, Serialize and    Deserialize will now return QueryParameter objects instead of strings. To get the actual values of a single query    parameter, use the Values field.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Reduced the amount of garbage generated when interacting with QueryParameters and when using the QueryString utility   class.</li> </ul>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>QueryParameter class to represent a single QueryParameter with is, possibly multiple, values.</li> </ul>"},{"location":"changelog/#035-2025-06-03","title":"[0.3.5] - 2025-06-03","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Sending a request with no data will no longer receive a content type of \"application/octet-stream\" and thus    potentially trigger a CORS Preflight request.</li> <li>Handling of content types when posting data has been improved to properly register the content type on the    UploadHandlerRaw and from that onto the Request's Headers.</li> </ul>"},{"location":"changelog/#034-2025-03-31","title":"[0.3.4] - 2025-03-31","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li><code>QueryString.Encode</code> throws a <code>NullValueException</code> when a <code>QueryParameters</code> object with a null value</li> </ul>"},{"location":"changelog/#033-2025-03-24","title":"[0.3.3] - 2025-03-24","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>A new <code>Header</code> value object to add headers to the Config object and Resource wrapper in an intuitive way</li> <li><code>Resource</code> now supports the <code>Header</code> class as an argument to the <code>With</code> method set to have a convenient way to   add headers using an intuitive interface</li> <li><code>Header</code> supports an explicit case from <code>Tuple&lt;string, string&gt;</code> to <code>Header</code> to easily instantiate them.</li> </ul>"},{"location":"changelog/#032-2025-02-17","title":"[0.3.2] - 2025-02-17","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Removed automatic setting of the application/octet-stream content type if a request's contents is null or a byte-array   when retrieving a Byte Array, including a texture. This will always trigger a CORS preflight, and some webservers seem    ill-equipped to handle this.</li> <li>Only create an ExpectedTypeOfResponse object if none is present in the configuration; this way you can pass your own    options to certain responses, such as setting the Readable flag for a texture.</li> </ul>"},{"location":"changelog/#031-2025-02-10","title":"[0.3.1] - 2025-02-10","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Removed automatic setting of the application/octet-stream content type if a request's contents is null or a byte-array   when retrieving the file as a cached FileInfo. This will always trigger a CORS preflight, and some webservers seem    ill-equipped to handle this.</li> </ul>"},{"location":"changelog/#030","title":"[0.3.0]","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>An uxios-specific User Agent string is now set by default instead of relying on the transport providing a user agent</li> <li>The Headers collection now features a basic series of constants describing headers that are added</li> <li>A Request Id is now available with Request objects, an internal id is used unless the user provides a header    X-Request-Id, in which case that will also internally be used as id for the request.</li> <li><code>Uxios.AsCoroutine</code> - a wrapper around a promise that will allow it to be used in situations where you just must    have a coroutine. Don't use this when you don't need to, some libraries require coroutines. See   https://kind-men.github.io/uxios/explanation/coroutines/ for more information.</li> <li>Automatic cancellation of requests if Coroutines are stopped using StopCoroutine. A Keep Alive mechanism is introduced   that will check whether a Coroutine / subprocess is alive every frame.</li> <li>Aborting a request will issue more specific Error: <code>RequestAbortedError</code>, which inherits from <code>ConnectionError</code>.</li> <li>Query strings can now be serialized and deserialized to and from structs/classes using <code>QueryString.Serialize</code> and   <code>QueryString.Deserialize</code> for type-safe declarations of query parameters.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Cancellation - you must now use <code>Uxios.Abort</code> to manually abort a promise' HTTP request instead of passing a    CancellationToken and managing the CancellationTokenSource manually. See    https://kind-men.github.io/uxios/guides/cancellation/ for more information.</li> <li>Added an interface above the Response object to make it easier to replace or change the response in the future</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Cancellation Tokens passed into the Config are now ignored - Uxios' new cancellation mechanism will completely manage   the tokens and source, use <code>Uxios.Abort</code> to abort a running promise</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Downloading files using the FileInfo generic sometimes errored because application/octetstream was given as mimtype,   but a webserver could return a 406 if it was configured to accept limited mime types for a file. To fix this, we   do not pass an accept header at all but let the browser figure it out.</li> </ul>"},{"location":"changelog/#020-2024-11-18","title":"[0.2.0] - 2024-11-18","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>AuthenticationError for all Authentication related errors</li> <li>UnauthorizedError when an unauthenticated user must authenticate to access the resource, or authentication    failed (HTTP 401)</li> <li>ForbiddenError when an authenticated user is not allowed to access the resource (HTTP 403)</li> <li>Support for Templated URI's, you can prepare a templated URI that will resolve with given parameters</li> <li>Full support for cancellation sources/tokens</li> <li>Support for authentication in the Resource class using the 'As' method</li> <li>Support for multiple Transports based on scheme - this is an experimental feature to verify whether it is possible   to load files from various locations based on the scheme</li> <li><code>unity+persistent</code> scheme that allows for files to be loaded and stored to and from the persistentDataPath in Unity,   even on WebGL</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Errors now can -and should- have a reference to an innerException for better traceability</li> <li>Json conversion is now done as a system-default response interception</li> <li>Interceptors are no longer static - but for the moment only the ones on the default instance are executed. A future   change will make interceptors instance specific and copy an initial set from the default instance; similar    to <code>axios.create()</code></li> <li>Config is no longer cloneable - a new static method has been introduced that creates a new Config based on another</li> <li>TemplatedUri's Resolve method is more optimized to reduce garbage generation</li> <li>The \"request\" field and arguments in the Error classes has been renamed to \"config\" to better explain the difference   between request objects and config objects</li> <li>Adding a new query parameter to a Resource class using the <code>With</code> method has its signature changed from    <code>KeyValuePair&lt;string, string&gt;</code> to the arguments <code>string</code>,<code>string</code> to simplify the API.</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Errors generated as part of a response were created as a generic error instead of a specific error</li> <li>Bug where an empty response in an error would throw an \"Invalid Cast\" issue and blocking error handling</li> <li>Various edge cases that would -or could- result in a null-value exception</li> </ul>"},{"location":"changelog/#013-2024-11-13","title":"[0.1.3] - 2024-11-13","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Support for directly downloading files and returning a FileInfo object by passing the FileInfo type as a generic</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>A failure to parse the JSON response would result in an error without response data, but we do want that to debug    the issue, Uxios now resolves the types in a second phase, enabling us to separate this out in a future change</li> </ul>"},{"location":"changelog/#012-2024-11-13","title":"[0.1.2] - 2024-11-13","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li><code>ConsoleLogger</code> middleware that will dispatch any request and response to the Debug.Log - for now internally used to    verify the concept, but intended for adding a Network Inspection tool similar to chrome</li> <li>Support for adding credentials to the query string by instantiating a <code>QueryParameterCredentials</code> object and passing it   to the <code>Auth</code> field of a <code>Config</code> object</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li><code>RequestInterceptor</code> was called after <code>Request</code> had been created - but must be before so that the interceptors can    change the <code>Config</code> object, and thus influencing <code>Request</code> creation.</li> <li>UnityWebRequest could not be found in QueryString.cs in WebGL builds</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Refactored <code>UnityWebRequestTransport</code> to have common actions between all transports to be in <code>TransportActions</code></li> <li>Introduced new <code>InMemoryTransport</code> for testing purposes</li> <li>Moved specialized <code>Response</code> classes for transports into <code>Transport</code> namespace and folder</li> </ul>"},{"location":"changelog/#011-2024-11-09","title":"[0.1.1] - 2024-11-09","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Using the Sprite generic to translate URLs into Sprites work now</li> </ul>"},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Added a new Sample to demonstrate basic usage to tie Uxios onto a UI</li> <li>Support for authenticating with Bearer tokens when you instantiate BearerTokenCredentials and assign that    to Config.Auth</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Timeout value is now in milliseconds - this value was in seconds and did not match how Axios works, or frequent   uses of timeout.</li> </ul>"},{"location":"changelog/#010-2024-11-06","title":"[0.1.0] - 2024-11-06","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Support for GET requests, including (de)serialization to and from JSON</li> <li>Support for downloading Texture2D's directly from online images</li> <li>Support for GETting byte arrays</li> <li>The Axios API was modelled and filled in for the most part</li> <li>A \"Resource\" class was introduced to provide a convenient API for Unity users who are not used to Web lingo</li> <li>QueryString handling is provided by a port from querystring.js - Unity WebGL does not have access to native C# functionality</li> <li>Error handling is gradually being fine-tuned to provide specific error classes when an exception happens</li> <li>Interceptors have been implemented and will now allow inspection and manipulation of the Config and Response</li> <li>Basic Authentication support is provided</li> <li>A TemplatedUri wrapper is introduced as a beta functionality</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Uxios! We welcome improvements, bug fixes, and documentation enhancements. Please follow the steps below to ensure a smooth and effective contribution process.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<ol> <li> <p>Fork the Repository Begin by forking the Uxios repository to create your own copy.</p> </li> <li> <p>Create a Branch Work on a separate branch for each change. This keeps your contributions organized and makes it    easier for us to review.</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> </li> <li> <p>Make Changes and Add Tests</p> <ul> <li>Code Changes: All changes should be covered by PlayMode tests and, preferably, EditMode tests to ensure robust   functionality.</li> <li>Documentation: If you update or add to the documentation, please do so in the Documentation~ folder.</li> </ul> </li> <li> <p>Test Your Changes Ensure all tests pass before you submit your pull request.</p> </li> <li> <p>Verify Documentation Changes If you made changes to the documentation, you can preview them locally using the    following command:</p> </li> </ol> <pre><code>npm run watch\n</code></pre> <p>This command runs mkdocs in watch mode using Docker. Ensure Docker is installed before running this command. Any    changes in the Documentation~ folder will be visible instantly.</p> <ol> <li>Submit a Pull Request Once your changes are complete and tested, push your branch and submit a pull request.    Provide a clear description of the changes, explaining the purpose and functionality of your modifications.</li> </ol>"},{"location":"contributing/#code-style-and-guidelines","title":"Code Style and Guidelines","text":"<ul> <li>Follow existing code conventions.</li> <li>Document your code where necessary, especially for complex logic or public APIs.</li> </ul> <p>Thank you for helping make Uxios better for everyone! If you have any questions, please reach out or open an issue to discuss your ideas before making significant changes.</p>"},{"location":"features/","title":"Features","text":"<p>Designed with Unity developers in mind, Uxios brings the simplicity and flexibility of modern HTTP clients like Axios to the Unity environment. Whether you're building data-driven applications for WebGL, mobile, or desktop, Uxios provides an intuitive API to streamline HTTP requests, manage asynchronous data, and simplify error handling \u2014 all with minimal  code.</p> <p>Uxios offers a rich set of built-in features, from automatic serialization and deserialization to request interceptors and response transformations, allowing you to focus more on functionality and less on networking boilerplate. Explore the features below to see how Uxios can enhance your Unity project\u2019s networking capabilities.</p> <p> </p>"},{"location":"features/#intuitive-http-requests-for-unity","title":"Intuitive HTTP Requests for Unity","text":"<p>Send HTTP requests with familiar <code>Get</code>, <code>Post</code>, <code>Put</code>, and <code>Delete</code> methods, inspired by popular web libraries like Axios, making it easy for Unity developers to integrate APIs into their projects.</p> <p> Guide</p>"},{"location":"features/#resource-wrapper-for-apis","title":"Resource Wrapper for API's","text":"<p>Simplify API interactions with Uxios\u2019s <code>Resource</code> wrapper, which provides built-in caching for frequently accessed endpoints, improving efficiency and reducing redundant network calls.</p> <p> Guide</p>"},{"location":"features/#automatic-request-body-serialization","title":"Automatic Request Body Serialization","text":"<p>Easily send data in multiple formats, including <code>string</code>, <code>byte[]</code>, and custom objects, which are automatically serialized to JSON using Newtonsoft JSON.net. This streamlines data handling and allows for quick integration with JSON-based APIs.</p>"},{"location":"features/#strongly-typed-responses-with-automatic-deserialization","title":"Strongly-Typed Responses with Automatic Deserialization","text":"<p>Specify custom data types to directly map JSON responses into Unity objects using Newtonsoft JSON.net, reducing the need for manual parsing and enabling seamless data handling in Unity scripts.</p>"},{"location":"features/#dynamic-templated-uris-for-flexible-api-endpoints","title":"Dynamic Templated URIs for Flexible API Endpoints","text":"<p>Easily create dynamic URLs with placeholders like {id} for flexible HTTP requests. Uxios\u2019s <code>TemplatedUri</code> allows you  to specify templates that can be filled at runtime, simplifying path management for (RESTful) APIs with minimal  setup.</p> <p> Guide</p>"},{"location":"features/#support-for-binary-text-texture-and-sprite-responses","title":"Support for Binary, Text, Texture, and Sprite Responses","text":"<p>Retrieve data in various formats, including JSON, binary, plain text, textures, and sprites. Uxios automatically deserializes and converts API responses into the appropriate format, so you can work with images, JSON objects, or binary data directly.</p>"},{"location":"features/#promises-for-asynchronous-operations","title":"Promises for Asynchronous Operations","text":"<p>Use promises to handle async tasks, chaining actions and managing errors with ease. Built-in support for <code>.Then</code> and <code>.Catch</code> methods makes asynchronous workflows straightforward and keeps code clean.</p> <p> Promises?</p>"},{"location":"features/#easy-support-for-basic-authentication","title":"Easy Support for Basic Authentication","text":"<p>Integrate basic authentication effortlessly by providing credentials in the request configuration, making it easier to interact with protected API endpoints that require user credentials.</p>"},{"location":"features/#automatic-handling-of-headers-for-api-data-types","title":"Automatic Handling of Headers for API Data Types","text":"<p>Automatically add headers based on the type of object being sent or received. Uxios configures headers such as <code>Content-Type</code> for JSON or binary data, reducing manual setup and potential errors in data handling.</p>"},{"location":"features/#request-cancellation","title":"Request Cancellation","text":"<p>Gain control over long-running or unnecessary requests with built-in support for request cancellation. This allows you to optimize performance and resource use, particularly in complex applications with frequent network activity.</p> <p> Guide</p>"},{"location":"features/#flexible-request-and-response-customization","title":"Flexible Request and Response Customization","text":"<p>Fine-tune requests with customizable headers, query parameters, and body content. Each response includes detailed metadata, like headers and status codes, for advanced control and debugging.</p>"},{"location":"features/#built-in-error-handling","title":"Built-In Error Handling","text":"<p>Catch and handle errors at each step in the request process, ensuring that your app provides clear feedback and robust error messaging without additional complexity.</p> <p> Errors</p>"},{"location":"features/#interceptor-and-transformer-support","title":"Interceptor and Transformer Support","text":"<p>Modify requests and responses on the fly with interceptors and transformers, allowing for custom handling like token authentication or data transformation before or after a request.</p> <p> Interceptors?</p>"},{"location":"features/#complete-api-integration-sample","title":"Complete API Integration Sample","text":"<p>Explore the included <code>Pokemon</code> sample, demonstrating a fully functional integration with an API, showcasing how to fetch data, populate UI elements, handle loading states, and manage errors\u2014all using Uxios\u2019s intuitive structure.</p> <p> See it</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to the Uxios documentation! Uxios is a Unity-friendly library inspired by Axios, designed to make HTTP interactions in Unity simple, efficient, and familiar. In this guide, we\u2019ll introduce the <code>Resource</code> class as an easy way to get started with basic HTTP interactions. We\u2019ll also show you how to use Uxios\u2019s core HTTP methods (like <code>Get</code>) directly for more control when you need it.</p>"},{"location":"getting-started/#overview-of-the-resource-class","title":"Overview of the <code>Resource</code> Class","text":"<p>The <code>Resource</code> class in Uxios provides an easy-to-use interface for working with individual API resources. It\u2019s ideal if you need basic CRUD (Create, Read, Update, Delete) operations without worrying about low-level HTTP configuration. Using <code>Resource</code>, you can:</p> <ol> <li>Retrieve a Resource: Automatically fetch and cache data for a resource with lazy loading.</li> <li>Check if a Resource Exists: Easily check if a resource exists on the server.</li> <li>Update or Delete a Resource: Modify or remove a resource as needed.</li> </ol> <p>The <code>Resource</code> class manages caching and basic error handling, making it an ideal starting point for common use cases.</p>"},{"location":"getting-started/#using-the-resource-class","title":"Using the <code>Resource</code> Class","text":"<p>To use <code>Resource</code>, you simply define the endpoint URI and specify a type for the data you expect to receive. Let\u2019s walk through how to create a <code>Resource</code> instance, check if it exists, fetch its data, update it, and delete it.</p>"},{"location":"getting-started/#step-1-define-a-resource","title":"Step 1: Define a Resource","text":"<p>First, define the URI of the resource and specify a type. Here\u2019s how you can set up a <code>Resource</code> for a \"to-do\" item in a REST API (like the JSONPlaceholder API):</p> <pre><code>using KindMen.Uxios.Api;\nusing UnityEngine;\nusing System;\n\npublic class Example : MonoBehaviour\n{\n    private void Start()\n    {\n        // Define the base URI for the to-do item\n        Uri todoUri = new Uri(\"https://jsonplaceholder.typicode.com/todos/1\");\n\n        // Create a Resource instance\n        var todoResource = new Resource&lt;Todo&gt;(todoUri);\n    }\n}\n</code></pre> <p>In this example:</p> <ul> <li><code>Resource&lt;Todo&gt;</code> is created with <code>todoUri</code>, where <code>Todo</code> is a class that matches the expected structure of the JSON   data.</li> </ul>"},{"location":"getting-started/#step-2-check-if-the-resource-exists","title":"Step 2: Check if the Resource Exists","text":"<p>The <code>HasValue</code> property allows you to check if a resource exists before attempting to fetch or use it. This is especially useful for cases where the resource might not be available, and you want to handle that gracefully.</p> <pre><code>todoResource.HasValue\n    .Then(exists =&gt;\n    {\n        if (exists)\n        {\n            Debug.Log(\"Resource exists!\");\n        }\n        else\n        {\n            Debug.Log(\"Resource does not exist.\");\n        }\n    })\n    .Catch(error =&gt;\n    {\n        Debug.LogError(\"Error checking resource existence: \" + error.Message);\n    });\n</code></pre>"},{"location":"getting-started/#step-3-retrieve-the-resource-data","title":"Step 3: Retrieve the Resource Data","text":"<p>Once you know the resource exists, you can retrieve its data using the <code>Value</code> property. This property fetches the data if it isn\u2019t already cached, providing lazy loading with built-in caching.</p> <pre><code>todoResource.Value\n    .Then(todo =&gt;\n    {\n        Debug.Log(\"Title: \" + todo.Title);\n        Debug.Log(\"Completed: \" + todo.Completed);\n    })\n    .Catch(error =&gt;\n    {\n        Debug.LogError(\"Error fetching resource data: \" + error.Message);\n    });\n</code></pre> <p>In this example:</p> <ul> <li><code>todoResource.Value</code> returns a <code>Promise&lt;Todo&gt;</code>, where <code>Todo</code> is your data model. When resolved, you can access the   fields directly.</li> </ul>"},{"location":"getting-started/#step-4-update-the-resource","title":"Step 4: Update the Resource","text":"<p>The <code>Update</code> method allows you to modify a resource and send the updated data to the server.</p> <pre><code>var updatedTodo = new Todo { Title = \"Updated Title\", Completed = true };\n\ntodoResource.Update(updatedTodo)\n    .Then(todo =&gt;\n    {\n        Debug.Log(\"Updated Title: \" + todo.Title);\n    })\n    .Catch(error =&gt;\n    {\n        Debug.LogError(\"Error updating resource: \" + error.Message);\n    });\n</code></pre>"},{"location":"getting-started/#step-5-delete-the-resource","title":"Step 5: Delete the Resource","text":"<p>The <code>Remove</code> method allows you to delete the resource from the server and clears the cached data.</p> <pre><code>todoResource.Remove()\n    .Then(() =&gt; Debug.Log(\"Resource deleted.\"))\n    .Catch(error =&gt; Debug.LogError(\"Error deleting resource: \" + error.Message));\n</code></pre>"},{"location":"getting-started/#using-uxios-directly-for-more-control","title":"Using Uxios Directly for More Control","text":"<p>While the <code>Resource</code> class is great for straightforward use cases, Uxios also provides direct HTTP methods (<code>Get</code>, <code>Post</code>, <code>Put</code>, <code>Delete</code>, etc.) for more advanced control. Using these methods directly offers several advantages:</p> <ol> <li>Custom Configuration: Uxios\u2019s HTTP methods accept configuration options, allowing you to set headers, timeouts,    query parameters, and more.</li> <li>Detailed Response Object: When using <code>Get</code> directly, you receive a <code>Response</code> object, which includes detailed    information about the request, such as the status code, headers, and the raw data.</li> </ol> <p>Here\u2019s an example of using <code>Uxios.Get</code> with a custom configuration:</p>"},{"location":"getting-started/#example-fetching-data-with-uxiosget","title":"Example: Fetching Data with <code>Uxios.Get</code>","text":"<pre><code>using KindMen.Uxios;\nusing UnityEngine;\nusing System;\n\npublic class ExampleGet : MonoBehaviour\n{\n    private void Start()\n    {\n        var uxios = new Uxios();\n        var url = new Uri(\"https://jsonplaceholder.typicode.com/todos/1\");\n\n        // Perform GET request with custom configuration\n        uxios.Get&lt;Todo&gt;(url, new Config\n        {\n            Headers = new Dictionary&lt;string, string&gt;\n            {\n                { \"Authorization\", \"Bearer your_token_here\" }\n            },\n            Timeout = 5000 // Set timeout to 5 seconds\n        })\n        .Then(response =&gt;\n        {\n            Debug.Log(\"Status: \" + response.Status);\n            Debug.Log(\"Title: \" + response.Data.Title);\n        })\n        .Catch(error =&gt;\n        {\n            Debug.LogError(\"Request failed: \" + error.Message);\n        });\n    }\n}\n</code></pre> <p>In this example:</p> <ul> <li><code>Uxios.Get&lt;Todo&gt;</code> performs a GET request to the specified URL.</li> <li>A custom <code>Config</code> is used to add an <code>Authorization</code> header and set a 5-second timeout.</li> <li>The <code>Response</code> object provides access to the status code (<code>response.Status</code>) and the typed data (<code>response.Data</code>).</li> </ul>"},{"location":"getting-started/#advantages-of-direct-uxios-methods","title":"Advantages of Direct Uxios Methods","text":"<ul> <li>Full HTTP Control: Customize requests for specific needs, such as setting headers, timeouts, or query parameters.</li> <li>Detailed Response Information: The <code>Response</code> object contains additional information (like headers and status   code) that isn\u2019t always needed but can be useful for debugging or special cases.</li> <li>Better for Complex API Calls: Direct methods are ideal for more complex or custom API interactions, where the   simpler <code>Resource</code> abstraction may be limiting.</li> </ul>"},{"location":"getting-started/#summary","title":"Summary","text":"<p>The <code>Resource</code> class in Uxios is a simple and powerful way to start working with API resources in Unity, providing an easy interface for basic CRUD operations and caching. For more control over HTTP requests, Uxios\u2019s core methods (<code>Get</code>, <code>Post</code>, <code>Put</code>, <code>Delete</code>) give you advanced configuration options and additional response details.</p>"},{"location":"getting-started/#when-to-use-resource-vs-direct-uxios-methods","title":"When to Use <code>Resource</code> vs. Direct Uxios Methods","text":"<ul> <li>Use <code>Resource</code>: For straightforward CRUD operations with basic caching and easy access to resource existence   checks.</li> <li>Use Direct Uxios Methods: For complex API interactions where you need fine-tuned control, custom headers, query   parameters, or more response details.</li> </ul> <p>This flexible setup lets you choose the approach that best fits your needs, whether you\u2019re looking for simplicity or advanced control in your Unity project.</p>"},{"location":"getting-support/","title":"Getting Support","text":"<p>Thank you for using Uxios! We\u2019re excited to support your journey with the library and have set up GitHub Discussions as a place for questions, feedback, and community interaction. Here\u2019s how to make the most of the support options available.</p>"},{"location":"getting-support/#where-to-go-for-help","title":"Where to Go for Help","text":"<p>Our GitHub Discussions section is open for:</p> <ul> <li>Questions and How-To: Post questions about integrating or using Uxios in your Unity project.</li> <li>Feature Requests: Suggest new features or share ideas for improvement.</li> <li>Show and Tell: Share your projects! We\u2019d love to know how Uxios is making your development process easier.</li> <li>Open Discussions: Join broader conversations, explore best practices, and interact with the Uxios community.</li> </ul>"},{"location":"getting-support/#using-github-issues-for-bug-reports-only","title":"Using GitHub Issues for Bug Reports Only","text":"<p>To streamline our support efforts, please use GitHub Issues exclusively for bug reports. This separation helps the maintainer focus on bug fixes without sifting through general discussions. You can refer to our Submitting a Bug Report page for more details on reporting bugs.</p>"},{"location":"getting-support/#why-use-discussions","title":"Why Use Discussions?","text":"<p>Our GitHub Discussions create a central place for all Uxios-related topics, allowing everyone to:</p> <ul> <li>Learn from community discussions.</li> <li>Collaborate on features and improvements.</li> <li>Showcase unique projects and creative uses of Uxios.</li> </ul>"},{"location":"getting-support/#getting-started","title":"Getting Started","text":"<ul> <li>Visit the GitHub Discussions page.</li> <li>Browse or search for similar questions or topics.</li> <li>Start a new discussion if your topic isn\u2019t covered.</li> </ul> <p>Thank you for helping us build a collaborative Uxios community! We\u2019re excited to see the conversations and projects that emerge.</p>"},{"location":"reporting-bugs/","title":"Submitting a Bug Report","text":"<p>Thank you for helping improve Uxios! By reporting bugs, you help ensure a smoother experience for all users. Here\u2019s how to create an effective bug report:</p>"},{"location":"reporting-bugs/#where-to-report","title":"Where to Report","text":"<p>All bug reports should be submitted through the GitHub issue tracker.</p>"},{"location":"reporting-bugs/#important-information-to-include","title":"Important Information to Include","text":"<ol> <li> <p>Version Information    Specify the Uxios version where the issue occurred. Bugs may be fixed in newer versions, so if possible, upgrade to    the latest version and see if the issue persists. Mention the version number clearly.</p> </li> <li> <p>Detailed Reproduction Steps    Include clear, step-by-step instructions for reproducing the issue. Reproducibility is essential for us to understand    and troubleshoot the problem effectively. Reports lacking reproduction steps may not be addressed, as this    information is crucial for identifying the root cause.</p> </li> <li> <p>Expected and Actual Behavior    Describe what you expected to happen versus what actually happened. This helps clarify the issue and makes it easier    to track down.</p> </li> <li> <p>Environment Details    Include information about your development and production environment\u2014such as Unity version, platform (e.g., WebGL,    Android, etc.), and any relevant configuration settings.</p> </li> </ol>"},{"location":"reporting-bugs/#why-detailed-reports-matter","title":"Why Detailed Reports Matter","text":"<p>Uxios is an open-source project with limited maintenance time. Precise and thorough reports help us manage issues efficiently and make the most of available resources. When reports include all necessary details, it significantly reduces time spent on troubleshooting and leads to faster resolutions.</p>"},{"location":"reporting-bugs/#what-to-expect","title":"What to Expect","text":"<p>Once you submit a detailed report:</p> <ul> <li>We\u2019ll review the issue and confirm reproducibility.</li> <li>If necessary, we may request additional information or clarification.</li> <li>Accepted reports will be addressed based on priority and resources.</li> </ul> <p>Thank you for helping make Uxios a better tool for the community!</p>"},{"location":"why-axios/","title":"Why Port Axios Instead of JavaScript\u2019s fetch API?","text":"<p>While fetch is a powerful API for making network requests in JavaScript, Axios' model offers several advantages that make it a wonderful fit for Unity development in C#.</p> <p>Key reasons for choosing Axios as the foundation for Uxios include:</p> <ol> <li> <p>JSON Serialization and Deserialization: Axios has a built-in concept of serializing data to and from JSON, which    aligns naturally with how Unity developers often handle data. This minimizes boilerplate code and ensures a    streamlined experience for handling JSON-based APIs, a common requirement in game and application development.</p> </li> <li> <p>Interceptors: Axios\u2019s native support for request and response interceptors opens up a world of possibilities. Unity    developers can use interceptors to log network calls, handle authentication, or add error handling with ease. In a    debugging context, for example, interceptors allow for seamless logging of all networking calls, giving developers    insight into their application's network behavior without invasive code changes.</p> </li> <li> <p>Leverage C#\u2019s Strong Typing: The Axios-inspired approach in Uxios plays well with C#\u2019s powerful type system.    Developers can define and enforce types more strictly than in JavaScript, reducing runtime errors and making code    easier to maintain and refactor.</p> </li> </ol> <p>This combination of JSON handling, flexible interceptors, and strong typing in C# positions Uxios as a highly productive, efficient library for Unity developers building network-reliant applications.</p>"},{"location":"why-use-uxios-instead-of-unitywebrequest/","title":"Why Use Uxios Instead of UnityWebRequest?","text":"<p>Unity\u2019s built-in <code>UnityWebRequest</code> API, while powerful, can be verbose and cumbersome for developers building data-driven applications. Uxios streamlines HTTP networking in Unity by providing a more intuitive, feature-rich, and developer-friendly interface that\u2019s similar to popular web libraries like Axios. Here\u2019s why Uxios is a great choice over using <code>UnityWebRequest</code> directly:</p>"},{"location":"why-use-uxios-instead-of-unitywebrequest/#1-simplified-syntax-and-readability","title":"1. Simplified Syntax and Readability","text":"<p>With <code>UnityWebRequest</code>, performing even simple HTTP requests often requires multiple lines of boilerplate code, handling HTTP methods, parsing responses, and managing errors separately. Uxios consolidates this into easy-to-read methods (<code>Get</code>, <code>Post</code>, <code>Put</code>, <code>Delete</code>) that automatically manage request and response processing.</p> <p>For example, what might take a dozen lines of code with <code>UnityWebRequest</code> is reduced to a single line with Uxios, saving time and reducing errors. Developers can quickly create, send, and handle requests without diving into the complexities of Unity's networking layers.</p>"},{"location":"why-use-uxios-instead-of-unitywebrequest/#2-built-in-features-for-effortless-networking","title":"2. Built-In Features for Effortless Networking","text":"<p>Uxios includes numerous built-in features that simplify networking in Unity, eliminating the need to write custom code for common tasks. Some of these include:</p> <ul> <li>Promises for cleaner asynchronous operations, chaining success and error handling with <code>.Then</code> and <code>.Catch</code>   syntax.</li> <li>Automatic Serialization and Deserialization using Newtonsoft JSON.net, so you can work directly with   strongly-typed objects instead of manually parsing JSON.</li> <li>Automatic Header Management based on the data type, with <code>Content-Type</code> headers set automatically for JSON,   binary, or text data.</li> <li>Error Handling integrated into each request, making it easier to handle and display errors to users.</li> <li>Support for Basic Authentication and custom headers, making it simple to connect to secured APIs.</li> </ul> <p>With these features baked in, Uxios covers many common networking needs out-of-the-box, saving you from building or maintaining your own custom code for each.</p>"},{"location":"why-use-uxios-instead-of-unitywebrequest/#3-less-boilerplate-and-reusable-code","title":"3. Less Boilerplate and Reusable Code","text":"<p>With <code>UnityWebRequest</code>, developers often find themselves writing repetitive code for tasks like setting up headers, parsing JSON responses, and managing state. Uxios minimizes this by providing:</p> <ul> <li>Reusable request methods that handle these tasks automatically, reducing boilerplate and standardizing request   behavior across your project.</li> <li>Request Interceptors and Transformers, which allow you to add custom logic to requests and responses before or   after they are sent. This can be used to automatically add authentication tokens, log requests, or transform data   without rewriting code for each request.</li> </ul>"},{"location":"why-use-uxios-instead-of-unitywebrequest/#4-efficient-resource-management","title":"4. Efficient Resource Management","text":"<p>Uxios\u2019s Resource wrapper and caching capabilities make it easy to manage frequently accessed data. This reduces redundant network calls and helps with memory management, especially in applications that rely heavily on data synchronization or repetitive requests.</p> <p>By using Uxios, you eliminate the need to build custom caching logic or manage resource lifecycles, as Uxios does this for you.</p>"},{"location":"why-use-uxios-instead-of-unitywebrequest/#5-consistent-data-handling-with-automatic-serialization","title":"5. Consistent Data Handling with Automatic Serialization","text":"<p>Uxios automatically handles serialization of request bodies and deserialization of responses:</p> <ul> <li>Send data: Easily serialize request data from various formats (e.g., <code>string</code>, <code>byte[]</code>, custom objects) without   writing manual converters. Custom objects are automatically serialized to JSON, making integration with JSON APIs   seamless.</li> <li>Receive data: Response data is deserialized to strongly-typed objects, strings, textures, or sprites based on the   expected type. This makes it easy to work with API data in Unity without having to manually parse JSON or manage   texture loading.</li> </ul> <p>In summary, Uxios empowers Unity developers by providing a simplified, flexible, and powerful HTTP client designed specifically for Unity\u2019s needs. By choosing Uxios over <code>UnityWebRequest</code> directly, you can streamline development,  reduce boilerplate, and focus more on building features rather than managing networking code.</p>"},{"location":"community/release-process/","title":"Release Process","text":"<p>This document outlines the step-by-step procedure for updating the version, synchronizing files, and pushing changes to GitHub. By following this process, new versions are seamlessly deployed to OpenUPM, ensuring they\u2019re quickly available to the community.</p>"},{"location":"community/release-process/#step-1-update-the-version-string","title":"Step 1: Update the Version String","text":"<ul> <li>Update the <code>Uxios.Version</code> file with the new version string.</li> </ul>"},{"location":"community/release-process/#step-2-synchronize-packagejson","title":"Step 2: Synchronize <code>package.json</code>","text":"<ul> <li>Ensure the <code>version</code> field in <code>package.json</code> matches the updated version string.</li> </ul>"},{"location":"community/release-process/#step-3-update-the-changelog","title":"Step 3: Update the Changelog","text":"<ul> <li>Replace the <code>[Unreleased]</code> placeholder in the changelog with the new version string.</li> <li>Append the release date in <code>YYYY-mm-dd</code> format to the same line.</li> </ul>"},{"location":"community/release-process/#step-4-push-changes","title":"Step 4: Push Changes","text":"<ul> <li>Commit all changes and push them to the <code>main</code> branch on GitHub.</li> </ul>"},{"location":"community/release-process/#step-5-create-a-git-tag","title":"Step 5: Create a Git Tag","text":"<ul> <li>Create a tag for the new version, using the format <code>v[version]</code> (e.g., <code>v1.2.3</code>).</li> </ul>"},{"location":"community/release-process/#step-6-verify-openupm-pipeline","title":"Step 6: Verify OpenUPM Pipeline","text":"<ul> <li>Once the tag is created, OpenUPM's build pipeline will automatically run.</li> <li>Verify the pipeline status here.</li> </ul> <p>Upon completion, the new version will be available on OpenUPM.</p>"},{"location":"explanation/coroutines/","title":"Coroutines","text":""},{"location":"explanation/coroutines/#using-uxios-coroutine-support","title":"Using Uxios' Coroutine Support","text":"<p>While Uxios is built around modern asynchronous patterns using promises, there are scenarios where third-party libraries or other parts of your codebase rely on Unity\u2019s Coroutines. Uxios provides utility methods to bridge these two paradigms, allowing promises to work seamlessly in coroutine-based workflows.</p>"},{"location":"explanation/coroutines/#when-should-you-use-coroutine-support","title":"When Should You Use Coroutine support?","text":"<ol> <li> <p>Integration with Third-Party Libraries    Some libraries expect data processing or actions to occur within a coroutine. For instance, a library managing    animations or state changes might only function correctly when chained operations happen in a coroutine flow.</p> </li> <li> <p>PlayMode Testing in Unity    When writing PlayMode tests, Unity\u2019s test runner moves through the execution flow in a way that doesn\u2019t naturally    align with promises. Wrapping promises inside coroutines ensures you can control execution timing and perform    assertions at the right moments.</p> </li> <li> <p>Blocking Logic in Coroutines    Although not recommended for general usage, there may be cases where you need to block execution within a coroutine    until an asynchronous request completes (e.g., when synchronizing multiple actions).</p> </li> </ol>"},{"location":"explanation/coroutines/#how-to-use-coroutine-support","title":"How to Use Coroutine Support","text":""},{"location":"explanation/coroutines/#1-wrap-promises-for-coroutine-execution","title":"1. Wrap Promises for Coroutine Execution","text":"<p>Uxios provides the <code>AsCoroutine</code> method to wrap a promise, making it compatible with Unity\u2019s coroutine system. This allows you to start the promise as part of a coroutine, either directly or nested within another coroutine.</p> <p>Example:</p> <pre><code>IEnumerator FetchDataWithCoroutine()\n{\n    var promise = Uxios.DefaultInstance.Get&lt;string&gt;(new Uri(\"https://example.com/data\"));\n\n    // Handle success and error as usual\n    promise.Then(OnSuccess);\n    promise.Catch(OnError);\n\n    // Wrap the promise in a coroutine to be tracked or chained\n    yield return Uxios.AsCoroutine(promise);\n}\n</code></pre>"},{"location":"explanation/coroutines/#2-wait-for-promises-inside-coroutines","title":"2. Wait for Promises Inside Coroutines","text":"<p>If you need to block execution within a coroutine until a promise completes, use the <code>WaitForRequest</code> method. This converts a promise into a <code>CustomYieldInstruction</code>, which Unity can process in a <code>yield return</code> statement.</p> <p>Example:</p> <pre><code>IEnumerator WaitForRequestExample()\n{\n    var promise = Uxios.DefaultInstance.Get&lt;string&gt;(new Uri(\"https://example.com/data\"));\n\n    yield return Uxios.WaitForRequest(promise);\n\n    Debug.Log(\"This is executed after the request completed - or failed\");\n}\n</code></pre>"},{"location":"explanation/coroutines/#best-practices","title":"Best Practices","text":"<ul> <li>Avoid Overusing Blocking: Blocking coroutines with <code>WaitForRequest</code> is not ideal for performance. Promises are   designed to handle their own lifecycle without needing manual waits.</li> <li>Leverage Promises When Possible: Use <code>Then</code>, <code>Catch</code>, and <code>Finally</code> methods for asynchronous workflows to maintain   cleaner, non-blocking code.</li> <li>Understand When Coroutines are Necessary: Only use coroutines when required by third-party libraries, PlayMode   tests, or tightly coupled Unity systems.</li> </ul>"},{"location":"explanation/coroutines/#key-benefits","title":"Key Benefits","text":"<ul> <li>Flexibility: Ensures Uxios fits seamlessly into coroutine-heavy workflows or legacy systems.</li> <li>Cross-Paradigm Support: Allows developers to use promises where supported while maintaining compatibility with   coroutines.</li> <li>Utility in Testing: Makes PlayMode tests and coroutine-based assertions easier to manage.</li> </ul> <p>By bridging promises with coroutines, Uxios ensures that you can integrate modern asynchronous workflows into any Unity project, regardless of its dependency on coroutine-based logic.</p>"},{"location":"explanation/interceptors/","title":"Interceptors","text":"<p>Interceptors in Uxios are modular functions that can manipulate requests or responses at various stages of their lifecycle. They provide powerful control over how HTTP requests and responses are processed, allowing developers to implement custom logic such as authentication, logging, and error handling consistently across an application.</p>"},{"location":"explanation/interceptors/#types-of-interceptors","title":"Types of Interceptors","text":"<ol> <li> <p>Request Interceptors: These interceptors run before a request is sent to the server. They are often used to    modify headers (e.g., adding authentication tokens), transform request data, or log outgoing requests.</p> </li> <li> <p>Response Interceptors: These interceptors run after the server\u2019s response is received. They are commonly used for    handling errors, transforming response data, or logging responses.</p> </li> </ol>"},{"location":"explanation/interceptors/#interceptor-priorities","title":"Interceptor Priorities","text":"<p>In Uxios, interceptors are executed in a priority-based order, managed through a <code>PriorityList</code>. By default, interceptors run in the order they were added, as they share the same default priority. However, you can influence this execution order by assigning specific priorities to certain interceptors. For example, logging interceptors are given a high priority (10,000), ensuring they run after other interceptors have made modifications. This allows loggers to capture the final, modified request or response accurately.</p>"},{"location":"explanation/interceptors/#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Authentication: A request interceptor could attach a JSON Web Token (JWT) to each request\u2019s headers, ensuring   authenticated requests.</li> <li>Caching: A response interceptor could cache data for specific requests to optimize future load times.</li> <li>Logging: A logging interceptor with high priority can log the final version of requests and responses, capturing   any transformations applied by prior interceptors.</li> </ul>"},{"location":"explanation/interceptors/#interceptor-execution-flow","title":"Interceptor Execution Flow","text":"<ol> <li> <p>Requests: Request interceptors execute in ascending priority order, allowing higher-priority interceptors to run    last. Modifications made by a request interceptor will be passed along to the next interceptor in the chain.</p> </li> <li> <p>Responses: Response interceptors are also executed in ascending priority order, processing responses in a    predictable sequence before reaching the final consumer.</p> </li> </ol>"},{"location":"explanation/promises/","title":"Understanding Promises in Unity","text":""},{"location":"explanation/promises/#what-are-promises","title":"What Are Promises?","text":"<p>A Promise is a tool for managing asynchronous code, which means code that can run in the background and complete sometime in the future. Instead of freezing the game while waiting for an operation (like fetching data from a server), promises allow the game to keep running smoothly.</p> <p>In Unity, you\u2019re probably familiar with <code>coroutines</code>, which also handle asynchronous actions. Promises are another way  to handle these tasks, but with a different structure that provides better control, especially when dealing with complex sequences or dependencies between actions.</p>"},{"location":"explanation/promises/#why-use-promises","title":"Why Use Promises?","text":"<p>Imagine you\u2019re writing a Unity game that needs to:</p> <ol> <li>Check if a player\u2019s profile exists on a remote server.</li> <li>If it exists, fetch the profile data.</li> <li>Then update the profile with new data.</li> </ol> <p>Using promises allows you to define this workflow in a clear, structured way, so each step only begins when the previous one has finished. Promises also make it easy to handle errors at each step, simplifying complex sequences of actions.</p>"},{"location":"explanation/promises/#key-concepts-of-promises","title":"Key Concepts of Promises","text":"<ol> <li> <p>A Promise Represents a Future Result Think of a promise as a placeholder for a result that hasn\u2019t arrived yet.     The promise starts pending (waiting for the result). Once the operation finishes, the promise is either:</p> </li> <li> <p>Fulfilled (operation succeeded), or</p> </li> <li> <p>Rejected (operation failed with an error).</p> </li> <li> <p>Chaining Promises can be chained together, meaning you can specify that once one promise finishes, another action    should start. This makes it easier to set up sequences of tasks without nesting coroutines.</p> </li> <li> <p>Error Handling Promises let you handle errors at any step in the chain, helping to keep your code cleaner and     ensuring that errors don\u2019t stop the entire sequence.</p> </li> </ol>"},{"location":"explanation/promises/#how-promises-work","title":"How Promises Work","text":"<p>A promise is created with an operation, like fetching data or performing a calculation, that runs asynchronously. When this operation completes, the promise can do one of two things:</p> <ul> <li>Resolve (Success): The operation succeeded, and the result is ready.</li> <li>Reject (Failure): The operation failed, usually due to an error (e.g., network failure).</li> <li>You can \u201clisten\u201d for these outcomes and specify actions to take in each case.</li> </ul>"},{"location":"explanation/promises/#using-promises-in-unity","title":"Using Promises in Unity","text":""},{"location":"explanation/promises/#creating-and-handling-promises","title":"Creating and Handling Promises","text":"<p>In Unity, the RSG Promises library (https://github.com/Real-Serious-Games/C-Sharp-Promise) is commonly used for  handling promises. </p> <p>Here\u2019s a basic example:</p> <pre><code>using RSG;\nusing UnityEngine;\n\npublic class Example : MonoBehaviour\n{\n    private void Start()\n    {\n        FetchDataFromServer()\n            .Then(data =&gt; Debug.Log($\"Data fetched: {data}\"))\n            .Catch(error =&gt; Debug.LogError($\"Error fetching data: {error.Message}\"));\n    }\n\n    private IPromise&lt;string&gt; FetchDataFromServer()\n    {\n        return new Promise&lt;string&gt;(() =&gt;\n        {\n            // Simulate an async operation (e.g., network request)\n            bool success = true; // Assume the request is successful\n\n            if (success)\n            {\n                return \"Player data here\"; // Resolve the promise with the result\n            }\n\n            throw new System.Exception(\"Failed to fetch data\");\n        });\n    }\n}\n</code></pre>"},{"location":"explanation/promises/#explanation-of-the-code","title":"Explanation of the Code","text":"<ol> <li> <p><code>FetchDataFromServer</code>:</p> <ul> <li>This method creates a new <code>Promise&lt;string&gt;</code>, meaning it will eventually return a <code>string</code> value.</li> <li>Inside the promise, you either return (success) data or throw an exception (error) if something goes wrong.</li> </ul> </li> <li> <p>Handling the Result with <code>.Then</code>:</p> </li> <li> <p>The <code>Then</code> method specifies what happens when the promise resolves successfully. In this case, it logs the fetched       data.</p> </li> <li> <p>Handling Errors with <code>.Catch</code>:</p> </li> <li> <p>The <code>Catch</code> method specifies what happens if the promise is rejected. Here, it logs an error message if fetching       data fails.</p> </li> </ol>"},{"location":"explanation/promises/#why-promises-are-better-for-complex-sequences","title":"Why Promises Are Better for Complex Sequences","text":"<p>Suppose you want to perform multiple asynchronous operations in a specific order. With promises, you can chain  actions, ensuring each one completes before the next begins.</p> <p>For example, if you want to:</p> <ol> <li>Check if data exists,</li> <li>Fetch it if it does, and</li> <li>Update it afterward,</li> </ol> <p>you could write this with promises as follows:</p> <pre><code>private void Start()\n{\n    CheckDataExists()\n        .Then(exists =&gt;\n        {\n            if (exists)\n            {\n                return FetchData();\n            }\n            else\n            {\n                return Promise&lt;string&gt;.Rejected(\"No data to fetch.\");\n            }\n        })\n        .Then(data =&gt; UpdateData(data))\n        .Catch(error =&gt; Debug.LogError($\"An error occurred: {error.Message}\"));\n}\n\nprivate IPromise&lt;bool&gt; CheckDataExists()\n{\n    return new Promise&lt;bool&gt;((resolve, reject) =&gt;\n    {\n        // Simulate a check\n        bool exists = true;\n        resolve(exists);\n    });\n}\n\nprivate IPromise&lt;string&gt; FetchData()\n{\n    return new Promise&lt;string&gt;((resolve, reject) =&gt;\n    {\n        // Simulate fetching data\n        resolve(\"Fetched data\");\n    });\n}\n\nprivate IPromise UpdateData(string data)\n{\n    return new Promise((resolve, reject) =&gt;\n    {\n        // Simulate updating data\n        Debug.Log($\"Data updated: {data}\");\n        resolve();\n    });\n}\n</code></pre> <p>In this example:</p> <ul> <li>Each method (CheckDataExists, FetchData, UpdateData) returns a promise.</li> <li>The promises are chained together using Then, so each step only begins after the previous one finishes.</li> <li>If any step fails, the Catch at the end handles the error.</li> </ul>"},{"location":"explanation/promises/#summary-of-key-methods","title":"Summary of Key Methods","text":"<ul> <li><code>Then</code>: Specifies what to do when the promise succeeds. You can use it to chain multiple actions together.</li> <li><code>Catch</code>: Specifies what to do if the promise fails, catching errors and preventing them from stopping the entire    sequence.</li> <li><code>All</code> (Advanced): Allows multiple promises to run in parallel and waits for all of them to complete. Useful when    fetching multiple pieces of data at the same time.</li> </ul>"},{"location":"explanation/promises/#when-to-use-promises-vs-coroutines","title":"When to Use Promises vs. Coroutines","text":"<p>Both promises and coroutines handle asynchronous tasks, but promises provide more control, better error handling, and chaining for complex sequences. Use coroutines for simpler tasks or when you don\u2019t need extensive error handling or sequencing. Use promises when you have multiple asynchronous operations that depend on each other, need precise  control, or require robust error handling.</p>"},{"location":"explanation/promises/#final-thoughts","title":"Final Thoughts","text":"<p>Promises give you the power to structure asynchronous workflows with ease, clarity, and control. They\u2019re a bit like coroutines but designed to manage complex, dependent actions and errors more gracefully. Once you get the hang of promises, you\u2019ll find them a powerful tool for building responsive and stable Unity applications!</p>"},{"location":"explanation/restful-apis/","title":"REST(ful) API's","text":""},{"location":"explanation/restful-apis/#what-is-a-restful-api","title":"What is a REST(ful) API","text":"<p>In the world of APIs, REST (Representational State Transfer) is a popular architectural framework that provides guidelines for structuring and interacting with networked resources. Quite a few API's are often referred to as  \u201cRESTful\u201d because it's not a strict standard \u2014 implementations vary in adherence to REST principles, leading to  differences across APIs.</p> <p>Richardson\u2019s Maturity Model, developed by Leonard Richardson and expanded upon by Roy Fielding, categorizes REST implementations into four levels of maturity:</p> <ul> <li>Level 0: The API treats each call as an isolated request.</li> <li>Level 1: The API organizes resources using URIs to represent objects or entities.</li> <li>Level 2: The API uses standard HTTP methods (GET, POST, PUT, DELETE) to perform operations on resources.</li> <li>Level 3: The API includes hypermedia controls (HATEOAS) to allow clients to dynamically discover actions and   resources.</li> </ul> <p>Uxios is designed to provide out-of-the-box support up to Level 2 of this model through its <code>Resource</code> and  <code>Collection</code> classes, with partial support for Level 3. These classes offer a structured way to interact with resources and collections in RESTful APIs.</p> <p>Let's introduce these two briefly:</p> <ul> <li> <p>Resource: A single entity or object, like a specific user or item. The <code>Resource</code> class in Uxios allows you to   fetch, update, and delete individual resources.</p> </li> <li> <p>Collection: A group or list of resources, like a list of users or items. The <code>Collection</code> class in Uxios provides   methods for interacting with and managing collections of resources.</p> </li> </ul> <p>Since REST is a flexible framework, Uxios covers many common patterns, but the specifics, such as  Content Negotiation, may require customization. OpenAPI, for example, builds additional standards on top of REST to  provide a more uniform interface that can be added on top of Uxios, but is not provided out of the box.</p> <p>In the following chapters, we\u2019ll explore how to use Uxios\u2019s <code>Resource</code> and <code>Collection</code> classes to interact with RESTful APIs in a structured and effective way.</p>"},{"location":"guides/","title":"Guides","text":"<p>Welcome to the Guides! This section is designed to support you with in-depth tutorials, practical examples, and quick-reference solutions for working with Uxios in your Unity projects. Whether you\u2019re just starting or looking to deepen your knowledge, you\u2019ll find structured content here to help you unlock Uxios\u2019s full potential.</p>"},{"location":"guides/#main-guides-step-by-step-solutions","title":"Main Guides: Step-by-Step Solutions","text":"<p>Our primary set of guides offers detailed, longer-form guides that walk you through complex tasks and workflows. Each guide is crafted with real-world examples and code snippets to provide clarity and practical insights. Here, you\u2019ll find everything you need to achieve your objectives, from handling asynchronous data in Unity to managing API requests with custom configurations. These guides are perfect when you want a clear understanding of Uxios\u2019s capabilities and how to apply them effectively.</p>"},{"location":"guides/#bytesized-guides-quick-solutions-for-specific-tasks","title":"Bytesized Guides: Quick Solutions for Specific Tasks","text":"<p>Alongside the main guides, we have our Bytesized section \u2014 a collection of super-short,  targeted guides focused on single tasks. These quick-reference tutorials show you how to accomplish specific actions,  like setting up basic authentication or passing a query parameter, in just a few lines. If you\u2019re in a hurry or need a  refresher on a particular topic, Bytesized guides give you the information you need without any extra context.</p>"},{"location":"guides/building-an-automatic-loader/","title":"Building an Automatic Loader","text":"<p>In this guide, we\u2019ll create a loader panel in Unity that automatically shows when a request is in progress and hides when the request completes. The example uses a <code>PromiseLoaderPanel</code> class with the <code>ShowWhile</code> method to manage the loader's visibility. This loader works with promises from the RSG Promises library, ensuring that the loader panel remains active until the promise resolves (successfully or with an error) and then automatically hides.</p> <p>This approach keeps your code clean and provides a smooth user experience, as the loader is only visible when needed.</p>"},{"location":"guides/building-an-automatic-loader/#how-it-works","title":"How It Works","text":"<p>The <code>PromiseLoaderPanel</code> class is a Unity component that displays a UI panel when a request is running. By calling the <code>ShowWhile</code> method, you:</p> <ol> <li>Activate the loader panel when the request starts.</li> <li>Automatically hide the loader panel when the request completes, whether it succeeds or fails.</li> </ol> <p>Using the <code>.Finally</code> method on a promise ensures that the loader panel will always hide, regardless of whether the promise resolves successfully or with an error.</p>"},{"location":"guides/building-an-automatic-loader/#step-1-set-up-the-loader-panel-in-unity","title":"Step 1: Set Up the Loader Panel in Unity","text":"<ol> <li> <p>Create a New UI Panel:</p> <ul> <li>In the Unity editor, go to GameObject &gt; UI &gt; Panel to create a new UI panel.</li> <li>Name it <code>LoaderPanel</code> and customize its appearance as desired (e.g., add a loading spinner or \"Loading...\" text).</li> </ul> </li> <li> <p>Add the <code>PromiseLoaderPanel</code> Script:</p> <ul> <li>Create a new C# script called <code>PromiseLoaderPanel</code>.</li> <li>Attach this script to the <code>LoaderPanel</code> GameObject.</li> </ul> </li> <li> <p>Set the Panel to Inactive:</p> <ul> <li>In the Unity editor, select the <code>LoaderPanel</code> and uncheck the Active checkbox to ensure it starts inactive.</li> </ul> </li> </ol>"},{"location":"guides/building-an-automatic-loader/#step-2-write-the-promiseloaderpanel-script","title":"Step 2: Write the <code>PromiseLoaderPanel</code> Script","text":"<p>Here\u2019s the code for <code>PromiseLoaderPanel</code>, which includes the <code>ShowWhile</code> method:</p> <pre><code>using RSG;\nusing UnityEngine;\n\nnamespace KindMen.Uxios.UI\n{\n    public class PromiseLoaderPanel : MonoBehaviour\n    {\n        /// &lt;summary&gt;\n        /// Displays the panel while the promise is pending and hides it after the promise resolves,\n        /// regardless of success or failure.\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"promise\"&gt;The promise to track for completion.&lt;/param&gt;\n        /// &lt;typeparam name=\"TData\"&gt;The type of data returned by the promise.&lt;/typeparam&gt;\n        /// &lt;returns&gt;The original promise, allowing further chaining.&lt;/returns&gt;\n        public IPromise&lt;TData&gt; ShowWhile&lt;TData&gt;(IPromise&lt;TData&gt; promise)\n        {\n            // Show the loader panel when the request starts\n            gameObject.SetActive(true);\n\n            // Hide the loader panel when the request completes, whether successful or failed\n            return promise.Finally(() =&gt; gameObject.SetActive(false));\n        }\n    }\n}\n</code></pre>"},{"location":"guides/building-an-automatic-loader/#explanation-of-the-code","title":"Explanation of the Code","text":"<p><code>ShowWhile&lt;TData&gt;</code>:</p> <ul> <li>This method takes a promise (<code>IPromise&lt;TData&gt;</code>) as a parameter, where <code>TData</code> is the data type the promise will   return upon completion.</li> <li><code>gameObject.SetActive(true);</code>: Activates the loader panel when the request begins.</li> <li><code>.Finally(() =&gt; gameObject.SetActive(false));</code>: The <code>.Finally</code> method hides the panel once the promise completes,   whether it succeeds or fails. This guarantees that the loader panel will always hide, regardless of the request's   outcome.</li> <li>The method returns the original promise, allowing further chaining of <code>.Then</code> or <code>.Catch</code> handlers if needed.</li> </ul>"},{"location":"guides/building-an-automatic-loader/#step-3-use-the-loader-in-your-code","title":"Step 3: Use the Loader in Your Code","text":"<p>Now that the loader panel is set up, you can use it to automatically manage the visibility of the loader whenever a promise-based request is made.</p>"},{"location":"guides/building-an-automatic-loader/#example","title":"Example","text":"<p>Here\u2019s an example of how to use the loader panel with a request:</p> <pre><code>using KindMen.Uxios;\nusing KindMen.Uxios.UI;\nusing UnityEngine;\nusing System;\n\npublic class ExampleLoaderUsage : MonoBehaviour\n{\n    public PromiseLoaderPanel loaderPanel;\n\n    private void Start()\n    {\n        // Define the URL for a sample request\n        var url = new Uri(\"https://jsonplaceholder.typicode.com/todos/1\");\n        var uxios = new Uxios();\n\n        // Make a GET request and show the loader while the request is pending\n        loaderPanel.ShowWhile(uxios.Get(url))\n            .Then(response =&gt;\n            {\n                Debug.Log(\"Request successful: \" + response.Data);\n            })\n            .Catch(error =&gt;\n            {\n                Debug.LogError(\"Request failed: \" + error.Message);\n            });\n    }\n}\n</code></pre> <p>In this example:</p> <ul> <li><code>loaderPanel.ShowWhile(uxios.Get(url))</code> starts a GET request to <code>url</code>, showing the loader panel while the request is   pending.</li> <li>The <code>Then</code> lambda function logs the response data if the request succeeds.</li> <li>The <code>Catch</code> lambda function logs an error if the request fails.</li> </ul> <p>Because of the <code>.Finally</code> in <code>ShowWhile</code>, the loader panel will automatically hide once the request completes, regardless of the outcome.</p>"},{"location":"guides/building-an-automatic-loader/#summary","title":"Summary","text":"<p>This setup allows you to easily manage a loading UI for asynchronous operations, showing and hiding the loader as needed. Here\u2019s a quick recap:</p> <ol> <li>Loader Activation: The <code>ShowWhile</code> method activates the loader when a promise is pending.</li> <li>Automatic Deactivation: Using <code>.Finally</code>, the loader hides itself once the promise completes.</li> <li>Flexible Use: You can use <code>ShowWhile</code> with any promise-based operation to ensure the loader appears only when    needed.</li> </ol> <p>This approach keeps your UI responsive and user-friendly, providing feedback to the player while the application is loading or processing data. You can further customize the loader panel by adding animations, custom messages, or progress indicators to enhance the experience.</p>"},{"location":"guides/building-urls-with-query-parameters/","title":"Dynamically Building URIs with Query Strings","text":""},{"location":"guides/building-urls-with-query-parameters/#introduction","title":"Introduction","text":"<p>In many applications, you might need to dynamically build URIs with query parameters based on user inputs or application state. Uxios provides tools like the <code>QueryString</code> utility and the <code>Resource</code> class to streamline this process. This guide will walk you through an example of combining an object representing query values with a base <code>System.Uri</code> to dynamically construct a URI. We'll then demonstrate how to pass this URI to a <code>Resource</code> while also highlighting the flexibility of the <code>With</code> method for additional customizations.</p>"},{"location":"guides/building-urls-with-query-parameters/#example-use-cases","title":"Example Use Cases","text":"<ol> <li>Search Functionality: Dynamically generate a URI for an API search endpoint, where query parameters include    filters, pagination, and sorting.</li> <li>Data-Driven Dashboards: Build URIs based on user-selected criteria, such as date ranges or selected metrics.</li> <li>Dynamic API Requests: Construct endpoints that adapt based on runtime data, such as user-specific or    device-specific parameters.</li> </ol>"},{"location":"guides/building-urls-with-query-parameters/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"guides/building-urls-with-query-parameters/#step-1-define-the-query-parameter-object","title":"Step 1: Define the Query Parameter Object","text":"<p>Define an object that represents the values for the query string. This could be a simple class or an anonymous object.</p> <pre><code>var queryParameters = new\n{\n    search = \"Unity\",\n    page = 1,\n    limit = 10,\n    sort = \"desc\"\n};\n</code></pre>"},{"location":"guides/building-urls-with-query-parameters/#step-2-serialize-the-query-object-into-a-query-string","title":"Step 2: Serialize the Query Object into a Query String","text":"<p>Use the <code>QueryString.Serialize</code> method to convert the object into a URL-encoded query string.</p> <pre><code>string queryString = QueryString.Serialize(queryParameters);\n// Output: \"search=Unity&amp;page=1&amp;limit=10&amp;sort=desc\"\n</code></pre>"},{"location":"guides/building-urls-with-query-parameters/#step-3-combine-the-query-string-with-a-base-uri","title":"Step 3: Combine the Query String with a Base URI","text":"<p>Combine the query string with a base URI to dynamically construct the full URI.</p> <pre><code>Uri baseUri = new Uri(\"https://api.example.com/resources\");\nstring fullUri = $\"{baseUri}?{queryString}\";\n// Output: \"https://api.example.com/resources?search=Unity&amp;page=1&amp;limit=10&amp;sort=desc\"\n</code></pre> <p>Alternatively, you can create a <code>System.UriBuilder</code> for better control:</p> <pre><code>var uriBuilder = new UriBuilder(baseUri)\n{\n    Query = queryString\n};\n\nUri finalUri = uriBuilder.Uri;\n// Output: \"https://api.example.com/resources?search=Unity&amp;page=1&amp;limit=10&amp;sort=desc\"\n</code></pre>"},{"location":"guides/building-urls-with-query-parameters/#step-4-pass-the-uri-to-the-uxios-resource","title":"Step 4: Pass the URI to the Uxios Resource","text":"<p>Create a <code>Resource</code> instance with the dynamically built URI and use it to make API calls.</p> <pre><code>var resource = new Resource(finalUri);\nresource.Get().Then(response =&gt;\n{\n    Debug.Log($\"Data received: {response.Data}\");\n}).Catch(error =&gt;\n{\n    Debug.LogError($\"Error: {error.Message}\");\n});\n</code></pre>"},{"location":"guides/building-urls-with-query-parameters/#alternative-customize-query-parameters-using-the-with-method","title":"Alternative: Customize Query Parameters Using the <code>With</code> Method","text":"<p>The <code>Resource</code> class also allows adding or overriding query parameters at runtime using the <code>With</code> method. This is useful for cases where query parameters are partially predefined but need dynamic adjustments.</p> <pre><code>resource.With(new QueryParameters\n{\n    search = \"C#\",\n    page = 2\n}).Get().Then(response =&gt;\n{\n    Debug.Log($\"Data received for page 2: {response.Data}\");\n}).Catch(error =&gt;\n{\n    Debug.LogError($\"Error: {error.Message}\");\n});\n</code></pre>"},{"location":"guides/building-urls-with-query-parameters/#full-code-example","title":"Full Code Example","text":"<pre><code>using System;\nusing KindMen.Uxios;\nusing UnityEngine;\n\npublic class QueryStringExample : MonoBehaviour\n{\n    void Start()\n    {\n        // Step 1: Define the query parameters\n        var queryParameters = new\n        {\n            search = \"Unity\",\n            page = 1,\n            limit = 10,\n            sort = \"desc\"\n        };\n\n        // Step 2: Serialize the object into a query string\n        string queryString = QueryString.Serialize(queryParameters);\n\n        // Step 3: Combine with a base URI\n        Uri baseUri = new Uri(\"https://api.example.com/resources\");\n        var uriBuilder = new UriBuilder(baseUri)\n        {\n            Query = queryString\n        };\n\n        Uri finalUri = uriBuilder.Uri;\n\n        // Step 4: Pass the URI to the Resource\n        var resource = new Resource(finalUri);\n        resource.Get().Then(response =&gt;\n        {\n            Debug.Log($\"Data received: {response.Data}\");\n        }).Catch(error =&gt;\n        {\n            Debug.LogError($\"Error: {error.Message}\");\n        });\n\n        // Alternative: Pass query parameters using `With`\n        resource.With(new QueryParameters\n        {\n            search = \"C#\",\n            page = 2\n        }).Get().Then(response =&gt;\n        {\n            Debug.Log($\"Data received for page 2: {response.Data}\");\n        }).Catch(error =&gt;\n        {\n            Debug.LogError($\"Error: {error.Message}\");\n        });\n    }\n}\n</code></pre>"},{"location":"guides/building-urls-with-query-parameters/#summary","title":"Summary","text":"<p>This guide demonstrates how to:</p> <ol> <li>Define an object representing query parameters.</li> <li>Convert it to a query string using <code>QueryString.Serialize</code>.</li> <li>Dynamically build a URI with <code>System.Uri</code> or <code>UriBuilder</code>.</li> <li>Pass the URI to a <code>Resource</code> for API requests.</li> <li>Use the <code>With</code> method for additional flexibility.</li> </ol> <p>The <code>QueryString</code> utility and <code>Resource</code> class in Uxios simplify handling query strings, making your Unity applications more dynamic and adaptable.</p>"},{"location":"guides/cancellation/","title":"Cancelling Requests","text":"<p>In some scenarios, you may want to cancel a long-running HTTP request if it\u2019s no longer needed, such as when a user navigates away from a page or dismisses a loading UI. Uxios provides built-in support for cancelling requests, simplifying how you manage these situations.</p> <p>This guide explains how to cancel requests in Uxios using the <code>Abort</code> method or through coroutine-based automatic cancellation. By attaching promises to Uxios\u2019s <code>AbortController</code>, you can efficiently manage the lifecycle of HTTP requests in your Unity projects.</p> <p>Cancellation Mechanism</p> <p>It\u2019s the HTTP request that gets cancelled, not the promise itself. If the HTTP request has already completed, cancellation has no effect on the handling of the response.</p>"},{"location":"guides/cancellation/#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Cancelling a data fetch if the user leaves a page or closes a dialog.</li> <li>Stopping requests that are no longer relevant, saving resources and improving performance.</li> <li>Automatically aborting requests associated with coroutines when they stop.</li> </ul>"},{"location":"guides/cancellation/#step-1-start-the-request","title":"Step 1: Start the Request","text":"<p>Initiate the request using Uxios as you normally would. A promise is returned, which you can use to track and handle the request.</p> <pre><code>var url = new Uri(\"https://httpbin.org/delay/10\");\nvar promise = uxios.Get&lt;string&gt;(url);\n</code></pre> <p>In this example:</p> <ul> <li>The URL <code>https://httpbin.org/delay/10</code> simulates a delay, allowing you to test the cancellation mechanism.</li> </ul>"},{"location":"guides/cancellation/#step-2-cancel-the-request","title":"Step 2: Cancel the Request","text":"<p>To cancel the request, simply call the <code>Abort</code> method on the Uxios instance and pass in the promise. For example, if a user action triggers cancellation:</p> <pre><code>uxios.Abort(promise);\n</code></pre> <p>This aborts the associated HTTP request as soon as possible. If the request was already completed, this action will have no effect on the response handling.</p>"},{"location":"guides/cancellation/#using-promises-in-coroutines","title":"Using Promises in Coroutines","text":"<p>When using promises in a coroutine, you can utilize Uxios's built-in coroutine helpers,  such as <code>WaitForRequest</code> or <code>AsCoroutine</code>. These methods ensure that:</p> <ol> <li>The promise remains alive as long as the coroutine is running.</li> <li>If the coroutine unexpectedly stops, Uxios automatically calls <code>Abort</code> on the associated promise.</li> </ol> <p>Example:</p> <pre><code>private IEnumerator FetchData()\n{\n    var url = new Uri(\"https://httpbin.org/delay/10\");\n    var promise = uxios.Get&lt;string&gt;(url);\n\n    yield return promise.WaitForRequest();\n\n    Debug.Log(\"Request completed: \" + promise.CurState);\n}\n\nprivate StoppingACoroutine()\n{\n    var coroutine = StartCoroutine(FetchData);\n\n    // This will automatically abort the request in the\n    // next frame\n    StopCoroutine(coroutine);\n}        \n</code></pre> <p>If the coroutine is stopped, the associated promise will be aborted automatically. There\u2019s no need to manually manage cancellation in this scenario.</p>"},{"location":"guides/cancellation/#summary","title":"Summary","text":"<p>In this guide, you learned how to cancel requests in Uxios using the <code>Abort</code> method and the automatic cancellation mechanism for coroutines. Key takeaways:</p> <ul> <li>Step 1: Start a request as usual.</li> <li>Step 2: Cancel a request manually by calling <code>Abort</code> on the promise.</li> <li>Coroutine Handling: Promises used in coroutines are automatically aborted when the coroutine stops.</li> </ul>"},{"location":"guides/fetching-pokemon-using-get/","title":"Using <code>Uxios.Get</code> to fetch Pok\u00e9mon","text":"<p>This guide will walk you through using Uxios\u2019s <code>Get</code> method to retrieve a typed Pok\u00e9mon object from the Pok\u00e9mon API. This method allows flexibility by letting you add custom configurations to each request. We\u2019ll also compare this approach with Uxios\u2019s <code>Resource</code> wrapper, which is more convenient but less customizable.</p>"},{"location":"guides/fetching-pokemon-using-get/#why-use-uxioss-get-method","title":"Why Use Uxios\u2019s <code>Get</code> Method?","text":"<p>Using Uxios\u2019s <code>Get</code> method offers greater flexibility because:</p> <ol> <li>You can specify a custom configuration object for each request, allowing for fine-tuned     control.</li> <li>The <code>Get</code> method returns a detailed <code>Response</code> object, which includes additional     information about the request and response.</li> </ol> <p>In contrast, the <code>Resource</code> wrapper provides a more convenient way to work with an API  resource but with fewer configuration options. It also automatically caches responses, making it ideal for situations  where you frequently request the same data.</p>"},{"location":"guides/fetching-pokemon-using-get/#step-1-define-a-pokemon-class","title":"Step 1: Define a Pok\u00e9mon Class","text":"<p>Before making the request, define a <code>Pokemon</code> class that matches the JSON structure of the API response. This lets Uxios deserialize the response directly into this object type, making it easier to work with the data in Unity.</p> <pre><code>public class Pokemon\n{\n    public int id { get; set; }\n    public string name { get; set; }\n    public int height { get; set; }\n    public int weight { get; set; }\n}\n</code></pre> <p>This <code>Pokemon</code> class includes the most common fields in a Pok\u00e9mon API response, which you can expand as needed.</p>"},{"location":"guides/fetching-pokemon-using-get/#step-2-use-uxios-to-fetch-pokemon-data-with-a-custom-configuration","title":"Step 2: Use Uxios to Fetch Pok\u00e9mon Data with a Custom Configuration","text":"<p>Now that you have the <code>Pokemon</code> class, you can use Uxios\u2019s <code>Get</code> method to retrieve data and -optionally- specify custom configurations like headers or timeouts.</p>"},{"location":"guides/fetching-pokemon-using-get/#example-code","title":"Example Code","text":"<p>Basic Example</p> <pre><code>using KindMen.Uxios;\nusing UnityEngine;\nusing System;\nusing System.Collections.Generic;\n\npublic class PokemonExample : MonoBehaviour\n{\n    private void Start()\n    {\n        var uxios = new Uxios();\n        var url = new Uri(\"https://pokeapi.co/api/v2/pokemon/pikachu\");\n\n        // Perform GET request and specify Pokemon as the response type\n        uxios.Get&lt;Pokemon&gt;(url)\n            .Then(response =&gt;\n            {\n                Pokemon pokemon = response.Data;\n                Debug.Log(\"Pok\u00e9mon Name: \" + pokemon.name);\n                Debug.Log(\"Pok\u00e9mon ID: \" + pokemon.id);\n                Debug.Log(\"Height: \" + pokemon.height);\n                Debug.Log(\"Weight: \" + pokemon.weight);\n            })\n            .Catch(error =&gt;\n            {\n                Debug.LogError(\"Failed to retrieve Pok\u00e9mon data: \" + error.Message);\n            });\n    }\n}\n</code></pre> <p>Example with custom configuration</p> <pre><code>using KindMen.Uxios;\nusing UnityEngine;\nusing System;\nusing System.Collections.Generic;\n\npublic class PokemonExample : MonoBehaviour\n{\n    private void Start()\n    {\n        var uxios = new Uxios();\n        var url = new Uri(\"https://pokeapi.co/api/v2/pokemon/pikachu\");\n\n        // Custom configuration for this request\n        var config = new Config\n        {\n            Headers = new Headers\n            {\n                { \"Authorization\", \"Bearer your_token_here\" }\n            },\n            Timeout = 5000 // Set a timeout of 5 seconds\n        };\n\n        // Perform GET request with custom config and specify Pokemon as the response type\n        uxios.Get&lt;Pokemon&gt;(url, config)\n            .Then(response =&gt;\n            {\n                Pokemon pokemon = response.Data;\n                Debug.Log(\"Pok\u00e9mon Name: \" + pokemon.name);\n                Debug.Log(\"Pok\u00e9mon ID: \" + pokemon.id);\n                Debug.Log(\"Height: \" + pokemon.height);\n                Debug.Log(\"Weight: \" + pokemon.weight);\n            })\n            .Catch(error =&gt;\n            {\n                Debug.LogError(\"Failed to retrieve Pok\u00e9mon data: \" + error.Message);\n            });\n    }\n}\n</code></pre>"},{"location":"guides/fetching-pokemon-using-get/#explanation-of-the-code","title":"Explanation of the Code","text":"<p>Custom Configuration (<code>Config</code>)</p> <p>The <code>Config</code> object allows you to specify additional settings for this request:</p> <ul> <li>Headers: Add an authorization header or any other headers you may need.</li> <li>Timeout: Set a timeout specific to this request (in milliseconds).</li> </ul> <p>Sending a Typed GET Request</p> <p>By specifying <code>&lt;Pokemon&gt;</code> as the type parameter for <code>Get</code>, Uxios automatically deserializes the response into a <code>Pokemon</code> object, making it easy to work with the data.</p> <p>Handling the Response and Errors</p> <ul> <li><code>.Then</code>: If the request succeeds, this block is executed, and the Pok\u00e9mon data is available as a <code>Pokemon</code>   object inside the Response.</li> <li><code>.Catch</code>: If there\u2019s an error (e.g., network failure), the <code>.Catch</code> block handles it.</li> </ul>"},{"location":"guides/fetching-pokemon-using-get/#example-output","title":"Example Output","text":"<p>If the request succeeds, the console might show:</p> <pre><code>Pok\u00e9mon Name: pikachu\nPok\u00e9mon ID: 25\nHeight: 4\nWeight: 60\n</code></pre> <p>If the request fails, you\u2019ll see an error message like:</p> <pre><code>Failed to retrieve Pok\u00e9mon data: Network error\n</code></pre>"},{"location":"guides/fetching-pokemon-using-get/#comparing-uxioss-get-method-with-the-resource-wrapper","title":"Comparing Uxios\u2019s <code>Get</code> Method with the <code>Resource</code> Wrapper","text":""},{"location":"guides/fetching-pokemon-using-get/#when-to-use-the-get-method","title":"When to Use the <code>Get</code> Method","text":"<p>The <code>Get</code> method is ideal when you need:</p> <ul> <li>Custom configuration for a specific request (e.g., headers, query parameters, timeouts).</li> <li>Access to a detailed <code>Response</code> object, which provides extra information, such as status    codes and headers.</li> </ul> <p>This flexibility makes it useful for complex or unique API calls where you need more control over each request.</p>"},{"location":"guides/fetching-pokemon-using-get/#when-to-use-the-resource-wrapper","title":"When to Use the <code>Resource</code> Wrapper","text":"<p>The <code>Resource</code> wrapper is more convenient for straightforward use cases, where:</p> <ul> <li>Automatic caching is desired, as it caches the response and reuses it until explicitly refreshed.</li> <li>You want to simplify your code with easy-to-use methods like <code>Value</code>, <code>Update</code>, and <code>RemoveAsync</code> without   configuring each request individually.</li> </ul> <p>The <code>Resource</code> wrapper abstracts away many HTTP details, making it perfect for frequently accessed resources that don\u2019t need customization for each request.</p>"},{"location":"guides/fetching-pokemon-using-get/#summary","title":"Summary","text":"<p>Using Uxios\u2019s <code>Get</code> method with a typed object provides flexibility and control, allowing you to customize each request and access a detailed response. The <code>Resource</code> wrapper, on the other hand, offers a convenient, simplified interface with built-in caching.</p>"},{"location":"guides/fetching-pokemon-using-get/#key-takeaways","title":"Key Takeaways","text":"<ul> <li><code>Get</code> Method: Flexible and customizable; ideal for unique or complex requests.</li> <li><code>Resource</code> Wrapper: Convenient with automatic caching; ideal for frequently accessed resources that don\u2019t require   extensive configuration.</li> </ul> <p>Choose the approach that best fits your needs, whether you\u2019re looking for flexibility or ease of use in your Unity project.</p>"},{"location":"guides/fetching-pokemon/","title":"Using <code>Resource</code> to fetch Pok\u00e9mon","text":"<p>The Pok\u00e9mon API is a RESTful API that provides data on Pok\u00e9mon, moves, abilities, and more. In this example, we\u2019ll use it to retrieve data for a specific Pok\u00e9mon by its ID or name.</p>"},{"location":"guides/fetching-pokemon/#step-1-create-a-resource-for-a-pokemon","title":"Step 1: Create a Resource for a Pok\u00e9mon","text":"<p>First, let's set up a <code>Resource</code> instance for a specific Pok\u00e9mon, such as Pikachu. We\u2019ll use a string to define  the Pok\u00e9mon\u2019s URL -though <code>System.Uri</code> is supported as well-, and we\u2019ll define a <code>Pokemon</code> class to represent the  Pok\u00e9mon data model.</p> <p>Example: Setting up the Resource</p> <pre><code>using KindMen.Uxios.Api;\n\nstring url = \"https://pokeapi.co/api/v2/pokemon/pikachu\";\n\n// Create a Resource for Pikachu by URL\nvar pikachu = Resource&lt;Pokemon&gt;.At(url);\n</code></pre>"},{"location":"guides/fetching-pokemon/#step-2-check-if-the-pokemon-resource-exists","title":"Step 2: Check if the Pok\u00e9mon Resource Exists","text":"<p>Use the <code>HasValue</code> property of <code>Resource</code> to perform a HEAD request and check if the resource for \"Pikachu\" exists.  <code>HasValue</code> returns a <code>Promise&lt;bool&gt;</code> that resolves to true if the resource exists or false if it does not.</p> <p>New to promises?</p> <p>If you haven't worked with promises before, we have written an explanation on what promises are in contrast to  Coroutines, which you can find here.</p> <p>Example: Checking if the Resource Exists</p> <pre><code>pikachu.HasValue\n    .Then(exists =&gt;\n    {\n        if (exists)\n        {\n            Console.WriteLine(\"Pikachu exists in the Pok\u00e9mon API!\");\n        }\n        else\n        {\n            Console.WriteLine(\"Pikachu does not exist in the Pok\u00e9mon API.\");\n        }\n    })\n    .Catch(error =&gt;\n    {\n        Console.WriteLine($\"Error checking resource existence: {error.Message}\");\n    });\n</code></pre> <p>In this example:</p> <ol> <li>If the Pok\u00e9mon resource exists, the promise resolves with true, and you\u2019ll see a message confirming Pikachu\u2019s    existence.</li> <li>If the resource does not exist, HasValue resolves with false, and you\u2019ll get a message stating that Pikachu is not    found.</li> </ol>"},{"location":"guides/fetching-pokemon/#step-3-retrieve-pokemon-data-if-it-exists","title":"Step 3: Retrieve Pok\u00e9mon Data if It Exists","text":"<p>If the resource exists, you can use the <code>Value</code> property of <code>Resource</code> to fetch the actual data. <code>Value</code> returns a <code>Promise&lt;T&gt;</code>, where <code>T</code> is <code>Pokemon</code>, representing the model of the data fetched.</p> <p>Example: Fetching the Pok\u00e9mon Data</p> <pre><code>pikachu.HasValue\n    .Then(exists =&gt;\n    {\n        if (!exists)\n        {\n            Console.WriteLine(\"The Pok\u00e9mon resource does not exist; skipping data fetch.\");\n            return;\n        }\n\n        // Fetch the data\n        pikachu.Value\n            .Then(pokemon =&gt;\n            {\n                Console.WriteLine($\"Pok\u00e9mon Name: {pokemon.Name}\");\n                Console.WriteLine($\"Base Experience: {pokemon.BaseExperience}\");\n                Console.WriteLine($\"Height: {pokemon.Height}\");\n                Console.WriteLine($\"Weight: {pokemon.Weight}\");\n            })\n            .Catch(error =&gt; Console.WriteLine($\"Error fetching Pok\u00e9mon data: {error.Message}\"));\n    })\n    .Catch(error =&gt; Console.WriteLine($\"Error checking resource existence: {error.Message}\"));\n</code></pre> <p>In this example:</p> <ol> <li>After confirming that the Pok\u00e9mon resource exists with <code>HasValue</code>, we call <code>Value</code> to retrieve the data.</li> <li>The promise returned by <code>Value</code> resolves with the <code>Pokemon</code> data, which we then print to the console.</li> </ol> <p>Example 2: Checking whether it exists as part of the error handling</p> <p>You can also write this in a shorter form if you do not check its existence, but instead make use of the <code>NotFoundError</code> to check whether it could not be found while fetching it.</p> <pre><code>pikachu.Value\n   .Then(pokemon =&gt;\n   {\n       Console.WriteLine($\"Pok\u00e9mon Name: {pokemon.Name}\");\n       Console.WriteLine($\"Base Experience: {pokemon.BaseExperience}\");\n       Console.WriteLine($\"Height: {pokemon.Height}\");\n       Console.WriteLine($\"Weight: {pokemon.Weight}\");\n   })\n   .Catch(error =&gt; {\n       if (error is NotFoundError) {\n           Console.WriteLine(\"The Pok\u00e9mon resource does not exist.\")\n           return;\n       }\n       Console.WriteLine($\"Error fetching Pok\u00e9mon data: {error.Message}\")\n   });\n</code></pre>"},{"location":"guides/fetching-pokemon/#step-4-define-the-pokemon-data-model","title":"Step 4: Define the Pok\u00e9mon Data Model","text":"<p>The <code>Resource</code> class expects a type parameter, so you\u2019ll need a <code>Pokemon</code> class that matches the JSON structure returned by the Pok\u00e9mon API. Here\u2019s a simple model class for Pokemon with properties for some of the primary fields.</p> <pre><code>public class Pokemon\n{\n    public string Name { get; set; }\n    public int BaseExperience { get; set; }\n    public int Height { get; set; }\n    public int Weight { get; set; }\n}\n</code></pre> <p>You may want to add additional properties if you need more data fields from the API.</p>"},{"location":"guides/fetching-pokemon/#summary","title":"Summary","text":"<ul> <li>Step 1: Create a <code>Resource&lt;Pokemon&gt;</code> instance for a specific Pok\u00e9mon.</li> <li>Step 2: Use <code>HasValue</code> to check if the resource exists.</li> <li>Step 3: If it exists, use <code>Value</code> to fetch and display the data.</li> </ul> <p>With this approach, you can manage RESTful resources with <code>Resource</code>, making it easy to check for existence and retrieve data with asynchronous handling in a Unity-like syntax. This example demonstrates using the Pok\u00e9mon API, but you can adapt the pattern to work with any RESTful API.</p>"},{"location":"guides/fetching-untyped-json-responses/","title":"Fetching and mapping untyped JSON responses","text":"<p>The <code>Get</code> method in Uxios is used to make HTTP GET requests, which are commonly used to retrieve data from a server.</p> <p>This guide will show you how to:</p> <ol> <li>Set up and perform a GET request.</li> <li>Handle the response when the request succeeds.</li> <li>Catch and handle errors if the request fails.</li> </ol> <p>In this example, we\u2019ll fetch a sample JSON object from a mock API (<code>https://jsonplaceholder.typicode.com/todos/1</code>), a free API that returns sample data.</p>"},{"location":"guides/fetching-untyped-json-responses/#code-example","title":"Code Example","text":"<p>Here's the code to make a GET request with Uxios and handle the response or any errors:</p> <pre><code>using KindMen.Uxios;\nusing UnityEngine;\nusing System;\n\npublic class ExampleGet : MonoBehaviour\n{\n    private void Start()\n    {\n        // Initialize Uxios instance\n        var uxios = new Uxios();\n\n        // Define the URL to fetch data from\n        var url = new Uri(\"https://jsonplaceholder.typicode.com/todos/1\");\n\n        // Perform GET request\n        uxios.Get(url)\n            .Then(response =&gt;\n            {\n                // Handle the response on success\n                Debug.Log(\"Status: \" + response.Status); // Logs the HTTP status code\n                Debug.Log(\"Content: \" + response.Data); // Logs the response content\n            })\n            .Catch(error =&gt;\n            {\n                // Handle errors\n                Debug.LogError(\"Request failed: \" + error.Message);\n            });\n    }\n}\n</code></pre>"},{"location":"guides/fetching-untyped-json-responses/#explanation-of-the-code","title":"Explanation of the Code","text":"<ol> <li>Initialize Uxios</li> </ol> <pre><code>var uxios = new Uxios();\n</code></pre> <p>This line creates a new instance of <code>Uxios</code>, which provides access to the <code>Get</code> method and other HTTP request     methods.</p> <ol> <li>Define the URL</li> </ol> <pre><code>var url = new Uri(\"https://jsonplaceholder.typicode.com/todos/1\");\n</code></pre> <p>Here, we define the URL we want to fetch. In this case, we\u2019re accessing a mock API that returns a sample JSON object     with details about a \u201cto-do\u201d item.</p> <ol> <li>Perform the GET Request</li> </ol> <pre><code>uxios.Get(url)\n</code></pre> <p>The <code>Get</code> method sends a GET request to the specified URL. Since this operation takes time (especially with remote     servers), <code>Get</code> returns a promise that we can use to handle the result once it     completes.</p> <ol> <li> <p>Handle the Response with <code>.Then</code></p> <pre><code>.Then(response =&gt;\n{\n    Debug.Log(\"Status: \" + response.Status);\n    Debug.Log(\"Content: \" + response.Data);\n})\n</code></pre> <ul> <li>The <code>.Then</code> method specifies what to do if the GET request is successful.</li> <li><code>response.Status</code>: Logs the HTTP status code (e.g., <code>200</code> for OK) to help understand the server\u2019s response.</li> <li><code>response.Data</code>: Logs the content of the response, which contains the actual data returned by the server.</li> </ul> </li> <li> <p>Handle Errors with <code>.Catch</code></p> </li> </ol> <pre><code>.Catch(error =&gt;\n{\n    Debug.LogError(\"Request failed: \" + error.Message);\n});\n</code></pre> <ul> <li>The <code>.Catch</code> method specifies what to do if the GET request fails.</li> <li><code>error.Message</code>: Logs the error message, providing details about why the request failed (e.g., network issues or       server errors).</li> </ul>"},{"location":"guides/fetching-untyped-json-responses/#understanding-the-response-object","title":"Understanding the Response Object","text":"<p>The response object returned by <code>Uxios.Get</code> contains important data, such as:</p> <ul> <li>Status: The HTTP status code (e.g., <code>200</code> for a successful response).</li> <li>Data: The content of the response. This is where your actual data resides.</li> </ul> <p>In this example, <code>response.Data</code> holds a Newtonsoft JObject instance representing the JSON response, which you can  query or use directly in your application.</p>"},{"location":"guides/fetching-untyped-json-responses/#summary","title":"Summary","text":"<ul> <li><code>uxios.Get(url)</code>: Sends a GET request to the specified URL.</li> <li><code>.Then(response =&gt; { ... })</code>: Handles the successful response, logging the status code and response data.</li> <li><code>.Catch(error =&gt; { ... })</code>: Catches any errors, logging a failure message.</li> </ul> <p>This setup makes it easy to manage API calls, allowing your game to retrieve data from remote servers without freezing  or disrupting gameplay. You can also chain additional <code>.Then</code> or <code>.Catch</code> handlers if you need more complex workflows.</p>"},{"location":"guides/logging-to-the-console/","title":"Logging Requests, Responses, and Errors","text":"<p>In this guide, we\u2019ll explore how to log HTTP requests, responses, and errors directly to the console in Unity using Uxios's <code>ConsoleLogger</code>. The <code>ConsoleLogger</code> auto-registers a series of interceptors that capture and log each request, response, and any errors that occur. This is particularly useful for debugging and monitoring API interactions in real-time.</p> <p>To configure the <code>ConsoleLogger</code> to be always active, you can set it up within a <code>MonoBehaviour</code> that initializes the logger when the application starts. By doing this, the <code>ConsoleLogger</code> will remain active throughout the app's runtime, automatically logging each request, response, and any errors to the console. You\u2019ll also need to manage the logger\u2019s lifecycle to ensure it\u2019s disposed of properly when no longer needed.</p> <p>Here\u2019s how to set up an always-active <code>ConsoleLogger</code> in a <code>MonoBehaviour</code>.</p>"},{"location":"guides/logging-to-the-console/#step-1-create-the-logger-manager-script","title":"Step 1: Create the Logger Manager Script","text":"<p>Create a new script called <code>GlobalLogger</code> to manage the <code>ConsoleLogger</code> and ensure it remains active for the entire session.</p>"},{"location":"guides/logging-to-the-console/#globalloggercs","title":"GlobalLogger.cs","text":"<pre><code>using UnityEngine;\nusing KindMen.Uxios.Logging;\n\npublic class GlobalLogger : MonoBehaviour\n{\n    private ConsoleLogger logger;\n\n    private void Awake()\n    {\n        // Ensure only one instance of GlobalLogger exists\n        if (FindObjectsOfType&lt;GlobalLogger&gt;().Length &gt; 1)\n        {\n            Destroy(gameObject);\n            return;\n        }\n\n        // Persist the logger across scenes\n        DontDestroyOnLoad(gameObject);\n\n        // Initialize the ConsoleLogger, which auto-registers interceptors\n        logger = new ConsoleLogger();\n        Debug.Log(\"ConsoleLogger activated and interceptors registered.\");\n    }\n\n    private void OnDestroy()\n    {\n        // Dispose of the logger when this object is destroyed\n        logger?.Dispose();\n        Debug.Log(\"ConsoleLogger disposed and interceptors unregistered.\");\n    }\n}\n</code></pre>"},{"location":"guides/logging-to-the-console/#explanation","title":"Explanation","text":"<ol> <li> <p>Singleton Pattern: <code>FindObjectsOfType&lt;GlobalLogger&gt;().Length &gt; 1</code> ensures that only one instance of <code>GlobalLogger</code> exists in the scene.    If another instance is detected, it\u2019s destroyed to prevent duplicate logging.</p> </li> <li> <p>Persist Across Scenes: <code>DontDestroyOnLoad(gameObject);</code> keeps the <code>GlobalLogger</code> active across scene loads, allowing it to continue logging    in every scene.</p> </li> <li> <p>Initialize the ConsoleLogger:    The <code>ConsoleLogger</code> is instantiated in <code>Awake()</code>, which automatically registers interceptors to log every request,    response, and error. This way, the logger is configured once and remains active throughout the app\u2019s runtime.</p> </li> <li> <p>Dispose of the Logger: <code>OnDestroy()</code> ensures that the logger is disposed of properly when the <code>GlobalLogger</code> is destroyed, unregistering the    interceptors and freeing up resources.</p> </li> </ol>"},{"location":"guides/logging-to-the-console/#step-2-add-the-logger-to-your-scene","title":"Step 2: Add the Logger to Your Scene","text":"<ol> <li> <p>Attach <code>GlobalLogger</code> to a GameObject: In the Unity editor, create an empty GameObject in your starting scene (or    add it to an existing GameObject) and attach the <code>GlobalLogger</code> script to it.</p> </li> <li> <p>Set Up the Uxios Requests: Since the <code>ConsoleLogger</code> is now globally active, you don\u2019t need to set up additional    logging within your request code. Each request made with Uxios will automatically log details to the console.</p> </li> </ol>"},{"location":"guides/logging-to-the-console/#example-usage","title":"Example Usage","text":"<p>Here\u2019s an example of a Uxios request in another script. The <code>ConsoleLogger</code> will automatically intercept and log this request, response, or any errors without additional setup in this script.</p> <pre><code>using System;\nusing KindMen.Uxios;\nusing UnityEngine;\n\npublic class ExampleRequest : MonoBehaviour\n{\n    private void Start()\n    {\n        var url = new Uri(\"https://httpbin.org/html\");\n        var config = new Config { TypeOfResponseType = ExpectedTypeOfResponse.Text() };\n\n        // Sending a GET request, which will be logged by the always-active ConsoleLogger\n        var uxios = new Uxios();\n        uxios.Get(url, config)\n            .Then(response =&gt; Debug.Log(\"Received Response: \" + response.Data))\n            .Catch(error =&gt; Debug.LogError(\"Request failed: \" + error.Message));\n    }\n}\n</code></pre>"},{"location":"guides/logging-to-the-console/#console-output","title":"Console Output","text":"<p>With the <code>ConsoleLogger</code> configured globally, you\u2019ll see output for each request, response, and error as they occur.</p> <p>As an example, this is the output for a request:</p> <pre><code>[UXIOS] Sending request to https://httpbin.org/html: \n\n{\n  \"Url\": \"https://httpbin.org/html\",\n  \"Method\": {\n    \"Method\": \"GET\"\n  },\n  \"BaseUrl\": null,\n  \"TransformRequest\": [],\n  \"TransformResponse\": [],\n  \"Headers\": {},\n  \"Params\": [],\n  \"Data\": null,\n  \"Timeout\": 0,\n  \"Auth\": null,\n  \"TypeOfResponseType\": {\n    \"$type\": \"KindMen.Uxios.ExpectedTypesOfResponse.TextResponse, com.kind-men.uxios\"\n  },\n  \"MaxRedirects\": 5\n}\n</code></pre> <p>The <code>ConsoleLogger</code> automatically logs:</p> <ul> <li>Request Details: Logs HTTP method, URL, headers, and payload (if applicable).</li> <li>Response Details: Logs status code and response data.</li> <li>Error Details: Logs any error messages, including status codes and JSON-formatted error data.</li> </ul>"},{"location":"guides/logging-to-the-console/#summary","title":"Summary","text":"<p>By setting up the <code>ConsoleLogger</code> within a <code>GlobalLogger</code> <code>MonoBehaviour</code>, you enable always-on logging for Uxios requests, responses, and errors across your Unity application. This approach simplifies logging, requires minimal setup in individual scripts, and ensures interceptors are properly registered and disposed of when needed.</p>"},{"location":"guides/uri-templates/","title":"Using placeholders in URLs","text":"<p>Templated URIs in Uxios allow you to define dynamic URLs with placeholders that can be filled in at runtime. This feature is especially useful when working with RESTful APIs that require parameters in the URL path. This guide will show you how to use Templated URIs, as well as explain a key caveat when using them.</p>"},{"location":"guides/uri-templates/#introduction","title":"Introduction","text":"<p>A Templated URI is a URI string with placeholders, such as <code>{id}</code>, that can be replaced with actual values at runtime. Uxios immediately resolves these placeholders when they are passed to one of its actions (e.g., <code>Get</code>, <code>Post</code>). This immediate resolution helps prevent unintended replacements by clearly differentiating between templated and regular URIs. For example, if a URI includes characters resembling placeholders that aren't meant to be replaced, Uxios ensures they remain unaffected.</p>"},{"location":"guides/uri-templates/#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Fetching a specific resource by ID.</li> <li>Building dynamic API paths with multiple parameters.</li> </ul>"},{"location":"guides/uri-templates/#step-by-step-instructions","title":"Step-by-Step Instructions","text":""},{"location":"guides/uri-templates/#step-1-define-a-templated-uri","title":"Step 1: Define a Templated URI","text":"<p>Start by defining a <code>TemplatedUri</code> with placeholders for the parameters you want to replace. In this example, <code>{id}</code> is a placeholder for the resource ID in the URL path.</p> <pre><code>TemplatedUri template = new TemplatedUri(\"https://jsonplaceholder.typicode.com/posts/{id}\");\n</code></pre> <p>This URL defines <code>{id}</code> as a placeholder, which can be replaced with an actual value when the request is made.</p>"},{"location":"guides/uri-templates/#step-2-resolve-the-templated-uri-with-with","title":"Step 2: Resolve the Templated URI with <code>With</code>","text":"<p>The simplest way to resolve the placeholder is by using the <code>With</code> method on the <code>TemplatedUri</code> itself. This method directly supplies the necessary parameters, making it easy to replace placeholders without an intermediate configuration object.</p> <pre><code>TemplatedUri url = template.With(\"id\", \"1\");\nvar promise = uxios.Get&lt;ExamplePost&gt;(url);\n</code></pre> <p>In this approach:</p> <ul> <li>A new <code>TemplatedUri</code> instance is created, Where the <code>{id}</code> placeholder will be replaced by the value <code>1</code> upon   passing <code>url</code> to <code>uxios.Get</code>.</li> <li>This means that your original <code>template</code> remains unchanged and can be reused as a template for future requests.</li> </ul> <p>This approach provides both flexibility and simplicity, allowing you to define reusable URI templates and resolve them with different parameters as needed.</p>"},{"location":"guides/uri-templates/#alternative-use-config-and-using-for-more-flexibility","title":"Alternative: Use <code>Config</code> and <code>Using</code> for More Flexibility","text":"<p>For additional control, you can use a <code>Config</code> object to add parameters to the URI independently of the template, then resolve the URI with <code>Using</code>.</p> <ol> <li>Set up a <code>Config</code> object with the required parameters.</li> </ol> <pre><code>var config = new Config().AddParam(\"id\", \"1\");\n</code></pre> <ol> <li>Use the <code>Using</code> method on the Templated URI, passing in the parameters from the <code>Config</code> object.</li> </ol> <pre><code>TemplatedUri url = template.Using(config.Params);\nvar promise = uxios.Get&lt;ExamplePost&gt;(url, config);\n</code></pre> <p>In this approach:</p> <ul> <li>Upon passing <code>url</code> to <code>uxios.Get</code>, <code>{id}</code> is immediately replaced with the value from <code>config.Params</code>.</li> <li>Any resolved parameters are removed from the <code>Params</code> collection, allowing for reuse and cleaner configurations in   defining query strings or by interceptors.</li> </ul>"},{"location":"guides/uri-templates/#caveat-immediate-resolution-of-templated-uris","title":"Caveat: Immediate Resolution of Templated URIs","text":"<p>Templated URIs in Uxios are resolved as soon as they\u2019re passed to an action like <code>Get</code> or <code>Post</code>. This immediate resolution helps prevent unintended replacements in URIs that may contain placeholders resembling template properties, which are not meant to be replaced. Using Templated URIs also ensures a clear distinction between dynamic and static URIs.</p>"},{"location":"guides/uri-templates/#full-code-example","title":"Full Code Example","text":"<p>Here\u2019s the complete code example, demonstrating both methods of using Templated URIs with Uxios:</p> <pre><code>using KindMen.Uxios;\n\npublic void FetchPost()\n{\n    // Define a templated URI with a placeholder for 'id'\n    var template = new TemplatedUri(\"https://jsonplaceholder.typicode.com/posts/{id}\");\n\n    // Option 1: Use the 'With' method for direct parameter replacement\n    var promiseDirect = uxios.Get&lt;ExamplePost&gt;(template.With(\"id\", \"1\"));\n\n    // Option 2: Use a Config object to add parameters and resolve the URI\n    var config = new Config().AddParam(\"id\", \"1\");\n    var promiseWithConfig = uxios.Get&lt;ExamplePost&gt;(template.Using(config.Params), config);\n}\n</code></pre>"},{"location":"guides/uri-templates/#summary","title":"Summary","text":"<p>This guide showed how to use Templated URIs in Uxios for dynamic API requests:</p> <ul> <li>Using <code>With</code>: Directly replace placeholders with specific values for simplicity.</li> <li>Using <code>Config</code> and <code>Using</code>: Set parameters in a <code>Config</code> object and resolve placeholders for more flexibility.</li> </ul>"},{"location":"guides/working-with-persistent-data/","title":"Working with Persistent Data","text":"<p>Unity\u2019s <code>persistentDataPath</code> provides a location for storing data across sessions. This directory is platform-independent, making it ideal for saving data locally without worrying about platform-specific paths.</p> <p>Using <code>File.IO</code> is not recommended</p> <p>Using <code>File.IO</code> is not recommended in cross-platform Unity projects, especially in WebGL, where <code>File.IO</code> lacks compatibility. Instead, leveraging Uxios with the <code>unity+persistent:///</code> scheme ensures smooth file handling across all platforms, including WebGL.</p> <p>We endeauvour to include all the hacks and workarounds that you normally would need to do, if you were to build this yourself.</p>"},{"location":"guides/working-with-persistent-data/#step-1-saving-a-file-to-persistent-storage","title":"Step 1: Saving a File to Persistent Storage","text":"<ol> <li> <p>Prepare the File Data    Define the content to be stored, such as a string, JSON, or binary data.</p> </li> <li> <p>Use the <code>unity+persistent:///</code> Scheme    Create a URI using <code>unity+persistent:///</code> and the desired file path.</p> </li> </ol> <pre><code>var fileUri = new Uri(\"unity+persistent:///myFolder/myFile.txt\");\n</code></pre> <p>Why Three Slashes?</p> <p>In <code>unity+persistent:///</code>, the three slashes indicate an empty authority (host) section, which is typical in file  URIs. This structure (e.g., <code>file:///</code>) designates a root path without a specific server or domain. The three-slash  format keeps the URI standard while targeting Unity\u2019s <code>persistentDataPath</code> location.</p> <ol> <li>Send the Data Using Uxios    Use Uxios\u2019s <code>Put</code> method to save data to this URI:</li> </ol> <pre><code>var promise = uxios.Put(fileUri, data);\n</code></pre> <p>This approach mirrors a server file upload but instead saves to the local persistent path, ensuring cross-platform compatibility.</p>"},{"location":"guides/working-with-persistent-data/#step-2-retrieving-a-file-from-persistent-storage","title":"Step 2: Retrieving a File from Persistent Storage","text":"<ol> <li>Define the URI for the File    Specify the <code>unity+persistent:///</code> scheme with the file\u2019s path.</li> </ol> <pre><code>var fileUri = new Uri(\"unity+persistent:///myFolder/myFile.txt\");\n</code></pre> <ol> <li>Retrieve with a GET Request    Call Uxios\u2019s <code>Get</code> method, passing the URI, to retrieve file contents.</li> </ol> <pre><code>var promise = uxios.Get&lt;string&gt;(fileUri);\npromise.Then(response =&gt; {\n    Debug.Log(\"File content: \" + response.Data);\n});\n</code></pre>"},{"location":"guides/working-with-persistent-data/#summary","title":"Summary","text":"<p>Using the <code>unity+persistent:///</code> scheme:</p> <ul> <li>Simplifies cross-platform file management in Unity.</li> <li>Ensures compatibility with WebGL, mobile, and desktop by relying on <code>persistentDataPath</code>.</li> </ul>"},{"location":"guides/bytesized/","title":"Bytesized","text":"<p>Welcome to the Bytesized guides\u2014a collection of quick, straightforward tutorials designed to help you accomplish specific tasks in Uxios. These short guides provide just enough detail to get you up and running with essential features, from adding basic authentication to passing query parameters.</p> <p>Each Bytesized guide covers one specific topic, so you can dive right in and find the information you need without extra context. Perfect for when you\u2019re in a rush or just looking to refresh on a particular aspect, Bytesized guides are here to make using Uxios even easier.</p>"},{"location":"guides/bytesized/waiting-for-promises-inside-coroutines/","title":"Waiting for Promises Inside Coroutines","text":""},{"location":"guides/bytesized/waiting-for-promises-inside-coroutines/#overview","title":"Overview","text":"<p>When you need to block a coroutine until a promise completes, use <code>WaitForRequest</code>. This ensures the coroutine only continues after the promise resolves or rejects. While not ideal for performance, this is useful for tightly integrated workflows or tests.</p>"},{"location":"guides/bytesized/waiting-for-promises-inside-coroutines/#steps","title":"Steps","text":"<pre><code>IEnumerator WaitForData()\n{\n    // 1. Create the Promise\n    var promise = Uxios.DefaultInstance.Get&lt;string&gt;(new Uri(\"https://example.com/data\"));\n\n    // 2. Wait for the Promise to resolve\n    yield return UxiosHelpers.WaitForRequest(promise);\n\n    // 3. Perform actions after the promise resolved\n    Debug.Log(\"Promise is done, meaning any Then and Catch statements have been executed\");\n}\n</code></pre>"},{"location":"guides/bytesized/waiting-for-promises-inside-coroutines/#quick-notes","title":"Quick Notes","text":"<ul> <li>Use <code>WaitForRequest</code> when blocking is necessary, such as in tests or specific workflows.</li> </ul>"},{"location":"guides/bytesized/wrapping-promises-as-coroutines/","title":"Wrapping Promises as Coroutines","text":""},{"location":"guides/bytesized/wrapping-promises-as-coroutines/#overview","title":"Overview","text":"<p>Sometimes, you need to execute a promise inside Unity\u2019s coroutine system \u2014 for example, when a library or system  expects a coroutine. Use <code>AsCoroutine</code> to make any promise compatible with Unity coroutines.</p>"},{"location":"guides/bytesized/wrapping-promises-as-coroutines/#steps","title":"Steps","text":"<pre><code>IEnumerator FetchData()\n{\n    // 1. Create the Promise\n    var promise = Uxios.DefaultInstance.Get&lt;string&gt;(new Uri(\"https://example.com/data\"));\n\n    promise.Then(OnSuccess);\n    promise.Catch(OnError);\n\n    // 2. Wrap the Promise as IEnumerator\n    yield return Uxios.AsCoroutine(promise);\n}\n\nvoid OnSuccess(string data)\n{\n    Debug.Log(\"Data received: \" + data);\n}\n\nvoid OnError(Exception e)\n{\n    Debug.LogError(\"Request failed: \" + e.Message);\n}\n</code></pre>"},{"location":"guides/bytesized/wrapping-promises-as-coroutines/#quick-notes","title":"Quick Notes","text":"<ul> <li>Use <code>AsCoroutine</code> for seamless promise execution in coroutines.</li> </ul>"},{"location":"guides/bytesized/resource/authentication/","title":"Authenticating","text":""},{"location":"guides/bytesized/resource/authentication/#overview","title":"Overview","text":"<p>This guide shows you how to add (basic) authentication to your Uxios requests by providing a username and password, or using a token or credentials. With this quick setup, you can seamlessly access protected API endpoints that require user authentication.</p>"},{"location":"guides/bytesized/resource/authentication/#steps","title":"Steps","text":"<pre><code>// 1. Describe a `Resource` .. \nvar resource = Resource&lt;LoggedIn&gt;\n    // *At* a URL (as string) and\n    .At(\"https://httpbin.org/basic-auth/username/password\")\n    // *As* a User - identified by a Username and Password\n    .As(\"username\", \"password\");\n\n// 2. Start fetching the Value using `Promise&lt;Post&gt;`\nPromise&lt;LoggedIn&gt; promise = resource.Value;\n\n// 3. Declare what needs to happen on success - a lambda is used here, but a method works too \npromise.Then(loggedIn =&gt; Debug.Log(loggedIn.authenticated));\n\n// 4. Declare what needs to happen on success - a lambda is used here, but a method works too \npromise.Catch(exception =&gt; Debug.LogError(exception.Message));\n</code></pre>"},{"location":"guides/bytesized/resource/authentication/#highlights","title":"Highlights","text":"<ul> <li>The <code>As</code> method on a Resource helps you to describe \"as what user\" you want to interact with the Resource</li> <li>You can chain a series of options that describe the Resource (<code>At</code> and <code>As</code> in this case)</li> </ul>"},{"location":"guides/bytesized/resource/authentication/#quick-tips","title":"Quick Tips","text":"<ul> <li>You can also pass an instance of <code>Credentials</code> to the <code>As</code> method, for example a <code>BearerTokenCredential</code>.</li> <li>The <code>Exception</code> in the <code>Catch</code> part of the promise is an instance of <code>KindMen.Uxios.Error</code>, you can get more    information there.</li> <li>Authentication failures also end up in the <code>Catch</code> section - and they can easily be identified by their type:    <code>KindMen.Uxios.Errors.Http.AuthenticationError</code> or its subtypes for even more specificity.</li> </ul>"},{"location":"guides/bytesized/resource/fetching/","title":"Fetching resources","text":""},{"location":"guides/bytesized/resource/fetching/#overview","title":"Overview","text":"<p>This guide demonstrates how to use the <code>Resource</code> class to fetch data from an API with built-in caching and simplified access to RESTful resources. With just a few lines of code, you can retrieve data from a single endpoint while Uxios handles request setup and response management for you.</p>"},{"location":"guides/bytesized/resource/fetching/#steps","title":"Steps","text":"<pre><code>// 1. Describe a `Resource` .. *At* a URL (as string) \nvar resource = Resource&lt;Post&gt;.At(\"https://jsonplaceholder.typicode.com/posts/1\");\n\n// 2. Start fetching the Value using `Promise&lt;Post&gt;`\nPromise&lt;Post&gt; promise = resource.Value;\n\n// 3. Declare what needs to happen on success - a lambda is used here, but a method works too \npromise.Then(post =&gt; Debug.Log(post.title));\n\n// 4. Declare what needs to happen on success - a lambda is used here, but a method works too \npromise.Catch(exception =&gt; Debug.LogError(exception.Message));\n</code></pre>"},{"location":"guides/bytesized/resource/fetching/#highlights","title":"Highlights","text":"<ul> <li>The <code>At</code> method on a Resource helps you to describe \"At what URL\" you want to interact with the Resource</li> <li>Using the <code>Then</code> method you can add a callback, or delegate, that will be invoked once the data has downloaded from    the given URL.</li> <li>Using the <code>Catch</code> method you can add a callback, or delegate, that will be invoked if an error occurs. The exception   in the is of type <code>KindMen.Uxios.Error</code> or one of its subtypes.</li> </ul>"},{"location":"guides/bytesized/resource/fetching/#quick-tips","title":"Quick Tips","text":"<ul> <li>If you want a more \"classic\" way to get a Resource instead of <code>Resource&lt;TResponseType&gt;.At(url)</code> you can also use    <code>new Resource&lt;TResponseType&gt;(url)</code></li> <li>Using the <code>At</code> method you can chain actions together to configure the behaviour of a resource, such as the <code>With</code>    and <code>As</code> methods </li> <li>Instead of <code>string</code>, the <code>At</code> method also supports <code>System.Uri</code> object - or more precisely: under the hood it is all   converted to <code>System.Uri</code>.</li> <li>The <code>Exception</code> in the <code>Catch</code> part of the promise is an instance of    <code>KindMen.Uxios.Error</code>, you can get the response data through it.</li> </ul>"},{"location":"reference/config/","title":"<code>Config</code> object","text":"<p> Runtime/Scripts/Config.cs</p> <p>The <code>Config</code> class in Uxios enables detailed customization for each HTTP request, giving you control over headers, timeouts, request methods, and more. This configurability allows developers to precisely craft how each request is sent and how responses are handled, which is especially useful in complex API integrations or when working with non-standard server requirements.</p> <p>However, direct interaction with <code>Config</code> is often unnecessary. Uxios provides sensible defaults and convenient methods in the <code>Uxios</code> class and through <code>Resource</code> and <code>Collection</code> APIs. These features are designed to handle the common requirements of most HTTP requests, enabling a more streamlined and efficient approach to network calls in Unity applications.</p>"},{"location":"reference/config/#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Custom Authentication: When an API requires a unique authorization setup, <code>Config</code> can be used to add specific   headers or authentication tokens.</li> <li>Specialized Error Handling: Use <code>ValidateStatus</code> to control how different HTTP status codes are interpreted.</li> <li>Request Cancellation: Attach a <code>CancelToken</code> to abort requests when they\u2019re no longer needed, such as when a user   navigates away from a view.</li> </ul>"},{"location":"reference/config/#fields","title":"Fields","text":""},{"location":"reference/config/#url","title":"Url","text":"<p>Type: <code>Uri</code></p> <p>The primary URL for the request. This field must be set, and if the URL is a relative path (<code>UriKind.Relative</code>) and <code>BaseUrl</code> is defined, then <code>BaseUrl</code> is prepended to <code>Url</code>.</p>"},{"location":"reference/config/#method","title":"Method","text":"<p>Type: <code>HttpMethod</code> Default: <code>HttpMethod.Get</code></p> <p>Specifies the HTTP method (e.g., GET, POST, PUT). The default method is GET.</p>"},{"location":"reference/config/#baseurl","title":"BaseUrl","text":"<p>Type: <code>Uri</code> Default: <code>null</code></p> <p>The base URL that combines with relative URLs in the <code>Url</code> field, or null to use <code>Url</code> directly.</p>"},{"location":"reference/config/#headers","title":"Headers","text":"<p>Type: <code>Headers</code> Default: Empty</p> <p>Collection of headers to include in the request, allowing customization of standard headers like <code>Content-Type</code> and custom headers.</p>"},{"location":"reference/config/#params","title":"Params","text":"<p>Type: <code>QueryParameters</code> Default: Empty</p> <p>Collection of query parameters to append to the URL, serialized automatically.</p>"},{"location":"reference/config/#data","title":"Data","text":"<p>Type: <code>object</code> Default: <code>null</code></p> <p>The request body data, which can include types such as <code>string</code>, <code>byte[]</code>, or custom objects. Uxios serializes this to JSON when supported.</p>"},{"location":"reference/config/#timeout","title":"Timeout","text":"<p>Type: <code>int</code> (in milliseconds) Default: <code>0</code> (no timeout)</p> <p>Maximum time to wait for a response before timing out. Exceeding this results in a timeout error.</p>"},{"location":"reference/config/#auth","title":"Auth","text":"<p>Type: <code>AuthenticationCredentials</code> Default: <code>null</code></p> <p>Credentials for HTTP authentication, used for APIs requiring user authentication. This can be <code>BasicAuthenticationCredentials</code> (for Basic Authentication), <code>BearerTokenCredentials</code> (to include an <code>Authorization</code> header with a <code>bearer</code> token) or <code>QueryParameterCredentials</code> (to append a QueryParameter with a value to represent the user).</p>"},{"location":"reference/config/#typeofresponsetype","title":"TypeOfResponseType","text":"<p>Type: <code>ExpectedTypeOfResponse</code> Default: <code>ExpectedTypeOfResponse.JSON</code></p> <p>Defines the expected response type (e.g., JSON, binary, text) for automated deserialization.</p>"},{"location":"reference/config/#maxredirects","title":"MaxRedirects","text":"<p>Type: <code>int</code> Default: <code>5</code></p> <p>Sets the maximum number of allowed redirects for a request.</p>"},{"location":"reference/config/#validatestatus","title":"ValidateStatus","text":"<p>Type: <code>Func&lt;HttpStatusCode, bool&gt;</code> Default: Accepts status codes in the 2xx range</p> <p>Function for evaluating the HTTP status code. It\u2019s invoked to determine if a response is considered valid, useful for custom handling. The promise will be rejected if the request is considered invalid.</p>"},{"location":"reference/config/#canceltoken","title":"CancelToken","text":"<p>Type: <code>CancellationToken</code> Default: <code>CancellationToken.None</code></p> <p>Allows request cancellation if the provided token is triggered, helpful in interrupting unnecessary requests. See Cancelling Requests for a guide how to use this.</p>"},{"location":"reference/config/#methods","title":"Methods","text":""},{"location":"reference/config/#default","title":"Default","text":"<p>Returns: <code>Config</code></p> <p>Creates a default instance of Config with commonly used settings, which can be further customized.</p> <pre><code>var defaultConfig = Config.Default();\n</code></pre>"},{"location":"reference/config/#at","title":"At","text":"<p>Parameters: <code>Uri url</code> Returns: <code>Config</code></p> <p>Sets the <code>Url</code> field to the specified URI and returns the updated configuration.</p> <p>Overload: <code>At(Uri url, Uri baseUrl)</code></p> <p>Sets the <code>Url</code> field and assigns to the <code>BaseUrl</code> field if it is null, making it easy to set both in one call.</p> <p>These methods supports chaining, enabling a fluid interface for compact and readable configuration.</p>"},{"location":"reference/config/#usingmethod","title":"UsingMethod","text":"<p>Parameters: <code>HttpMethod method</code> Returns: <code>Config</code></p> <p>Sets the HTTP method (e.g., GET, POST) for the request.</p> <p>This method supports chaining, enabling a fluid interface for compact and readable configuration.</p>"},{"location":"reference/config/#cancelusing","title":"CancelUsing","text":"<p>Parameters: <code>CancellationTokenSource source</code> Returns: <code>Config</code></p> <p>Attaches a cancellation token, enabling request cancellation via the source token. See Cancelling Requests for a guide how to use this.</p> <pre><code>var configWithCancellation = config.CancelUsing(cancellationSource);\n</code></pre> <p>This method supports chaining, enabling a fluid interface for compact and readable configuration.</p>"},{"location":"reference/config/#addparam","title":"AddParam","text":"<p>Parameters: <code>string key</code>, <code>object value</code> Returns: <code>Config</code></p> <p>Adds a query parameter to the <code>Params</code> collection (Query Parameters).</p> <pre><code>var config = new Config().AddParam(\"id\", 123);\n</code></pre> <p>This method supports chaining, enabling a fluid interface for compact and readable configuration.</p>"},{"location":"reference/config/#addheader","title":"AddHeader","text":"<p>Parameters: <code>string key</code>, <code>string value</code> Returns: <code>Config</code></p> <p>Adds a header to <code>Headers</code>.</p> <pre><code>var config = new Config().AddHeader(\"Authorization\", \"Bearer token\");\n</code></pre> <p>This method supports chaining, enabling a fluid interface for compact and readable configuration.</p>"},{"location":"reference/config/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/config/#basic-configuration","title":"Basic Configuration","text":"<pre><code>var config = Config.Default()\n    .BaseUrl(new Uri(\"https://api.example.com\"))\n    .AddHeader(\"Authorization\", \"Bearer myToken\")\n    .Timeout(30000);\n</code></pre>"},{"location":"reference/config/#using-cancelusing-for-request-cancellation","title":"Using <code>CancelUsing</code> for Request Cancellation","text":"<pre><code>var cancellationSource = new CancellationTokenSource();\nvar config = Config.Default().CancelUsing(cancellationSource);\n</code></pre>"},{"location":"reference/config/#adding-query-parameters","title":"Adding Query Parameters","text":"<pre><code>var config = new Config().AddParam(\"page\", 1).AddParam(\"sort\", \"asc\");\n</code></pre>"},{"location":"reference/config/#summary","title":"Summary","text":"<p>The <code>Config</code> class allows extensive customization of HTTP requests in Uxios. It offers control over URL settings, authentication, timeout, and more, centralizing management and enabling effective API interactions.</p>"},{"location":"reference/error/","title":"Error Classes","text":"<p>In Uxios, errors are handled through a base family of error classes that represent various failure scenarios. These classes include the <code>Error</code> base class, as well as specific error types that match common HTTP and network issues. This hierarchy allows developers to catch and manage specific error types more effectively, improving error handling and debugging.</p>"},{"location":"reference/error/#overview-of-error-types","title":"Overview of Error Types","text":"<p>Errors in Uxios are grouped to align with UnityWebRequest\u2019s <code>UnityWebRequest.Result</code> result types, with additional categories to handle specific HTTP status families.</p> <ul> <li>ConnectionError: Represents connectivity-related issues (e.g., no internet connection, DNS resolution failure).</li> <li>DataProcessingError: Occurs when data processing fails, either due to network errors or issues with Uxios\u2019s own   processing, such as (de)serialization.</li> <li>ProtocolError: Relates to protocol-level errors like HTTP responses that signal a problem. This category is   further divided into <code>HttpClientError</code> and <code>HttpServerError</code>:<ul> <li>HttpClientError (4xx): Represents client-side HTTP errors (e.g., 404 Not Found, 400 Bad Request).</li> <li>HttpServerError (5xx): Represents server-side HTTP errors (e.g., 500 Internal Server Error, 503 Service   Unavailable).</li> </ul> </li> </ul>"},{"location":"reference/error/#error-classes_1","title":"Error Classes","text":""},{"location":"reference/error/#kindmenuxioserror","title":"KindMen.Uxios.Error","text":"<p>The base class for all error types in Uxios. It contains details about the original request (<code>Config</code>) and the response (<code>Response</code>) for more context.</p> <p>Fields</p> <ul> <li><code>Config</code>: The <code>Config</code> object representing the original request configuration.</li> <li><code>Response</code>: The <code>Response</code> object, which may contain status and data if a response was received.</li> </ul>"},{"location":"reference/error/#kindmenuxioserrorsconnectionerror","title":"KindMen.Uxios.Errors.ConnectionError","text":"<p>Represents an error that occurs due to connectivity issues, such as a lost network connection or DNS resolution failure. This type of error is particularly useful for catching network issues at the client level.</p> <p>Usage: Typically occurs when the <code>UnityWebRequest.Result</code> is <code>ConnectionError</code>.</p>"},{"location":"reference/error/#kindmenuxioserrorsdataprocessingerror","title":"KindMen.Uxios.Errors.DataProcessingError","text":"<p>Occurs when data processing fails. This includes errors from data parsing, serialization, and deserialization issues within Uxios. Additionally, any failure to process or parse response data received from the server may also raise this error.</p> <p>Usage: Occurs when Uxios encounters data-related issues, either due to network problems or failures in internal data handling, such as JSON deserialization.</p>"},{"location":"reference/error/#kindmenuxioserrorsprotocolerror","title":"KindMen.Uxios.Errors.ProtocolError","text":"<p>The base class for HTTP protocol errors, capturing general issues related to the HTTP status code received from the remote server.</p> <p>Fields</p> <ul> <li><code>Status</code>: The HTTP status code of the response, if available.</li> </ul> <p>Usage: Raised when there is a problem at the HTTP protocol level, often signifying a client or server error reported by the remote server.</p>"},{"location":"reference/error/#kindmenuxioserrorshttpclienterror","title":"KindMen.Uxios.Errors.HttpClientError","text":"<p>A subclass of <code>ProtocolError</code> representing client-side errors (4xx HTTP status codes). These errors indicate issues originating from the request, such as invalid parameters or unauthorized access.</p> <p>Usage: Typically occurs when the server responds with a 4xx status code, such as 404 Not Found or 403 Forbidden.</p>"},{"location":"reference/error/#kindmenuxioserrorshttpservererror","title":"KindMen.Uxios.Errors.HttpServerError","text":"<p>A subclass of <code>ProtocolError</code> representing server-side errors (5xx HTTP status codes). These errors indicate that something went wrong on the server, such as an internal server error or service unavailability.</p> <p>Usage: Typically occurs when the server responds with a 5xx status code, such as 500 Internal Server Error or 502 Bad Gateway.</p>"},{"location":"reference/querystrings/","title":"QueryStrings","text":"<p>The <code>QueryString</code> utility in Uxios simplifies handling URL query strings in Unity applications. It provides functionality for encoding, decoding, parsing, stringifying, and merging query strings, while supporting serialization to and from objects. This utility is designed to work across Unity platforms, including WebGL.</p>"},{"location":"reference/querystrings/#overview","title":"Overview","text":"<p>The <code>QueryString</code> utility replicates much of the functionality of Node.js's <code>querystring</code> API. It includes:</p> <ul> <li>Encoding/Decoding: Converts strings to/from URL-safe formats.</li> <li>Parsing: Converts query strings into key-value pairs.</li> <li>Stringifying: Converts key-value pairs into query strings.</li> <li>Merging: Combines multiple query strings or key-value collections.</li> <li>Serialization/Deserialization: Converts objects to query strings and vice versa.</li> </ul>"},{"location":"reference/querystrings/#methods","title":"Methods","text":""},{"location":"reference/querystrings/#1-escape-and-unescape","title":"1. <code>Escape</code> and <code>Unescape</code>","text":""},{"location":"reference/querystrings/#escape","title":"Escape","text":"<p>Escapes a string for safe use in a query string.</p> <pre><code>string escaped = QueryString.Escape(\"Hello World!\");\n// Output: \"Hello+World%21\"\n</code></pre>"},{"location":"reference/querystrings/#unescape","title":"Unescape","text":"<p>Unescapes a query string-encoded string.</p> <pre><code>string unescaped = QueryString.Unescape(\"Hello+World%21\");\n// Output: \"Hello World!\"\n</code></pre>"},{"location":"reference/querystrings/#2-encode-and-decode","title":"2. <code>Encode</code> and <code>Decode</code>","text":""},{"location":"reference/querystrings/#encode","title":"Encode","text":"<p>Converts a <code>QueryParameters</code> object into a query string.</p> <pre><code>var collection = new QueryParameters\n{\n    { \"key1\", \"value1\" },\n    { \"key2\", \"value2\" }\n};\n\nstring queryString = QueryString.Encode(collection);\n// Output: \"key1=value1&amp;key2=value2\"\n</code></pre>"},{"location":"reference/querystrings/#decode","title":"Decode","text":"<p>Parses a query string into a <code>QueryParameters</code> object.</p> <pre><code>string query = \"key1=value1&amp;key2=value2\";\nQueryParameters collection = QueryString.Decode(query);\n\n// collection[\"key1\"] == \"value1\"\n// collection[\"key2\"] == \"value2\"\n</code></pre>"},{"location":"reference/querystrings/#3-merge","title":"3. <code>Merge</code>","text":"<p>Combines two query strings or <code>QueryParameters</code> objects.</p>"},{"location":"reference/querystrings/#example-merging-query-strings","title":"Example: Merging Query Strings","text":"<pre><code>string query1 = \"key1=value1\";\nstring query2 = \"key2=value2\";\n\nstring mergedQuery = QueryString.Merge(query1, query2);\n// Output: \"key1=value1&amp;key2=value2\"\n</code></pre>"},{"location":"reference/querystrings/#example-merging-queryparameters-objects","title":"Example: Merging <code>QueryParameters</code> Objects","text":"<pre><code>var collection1 = new QueryParameters { { \"key1\", \"value1\" } };\nvar collection2 = new QueryParameters { { \"key2\", \"value2\" } };\n\nQueryParameters mergedCollection = QueryString.Merge(collection1, collection2);\n// mergedCollection[\"key1\"] == \"value1\"\n// mergedCollection[\"key2\"] == \"value2\"\n</code></pre>"},{"location":"reference/querystrings/#4-serialize-and-deserialize","title":"4. <code>Serialize</code> and <code>Deserialize</code>","text":""},{"location":"reference/querystrings/#serialize","title":"Serialize","text":"<p>Converts an object into a query string.</p> <pre><code>var parameters = new\n{\n    key1 = \"value1\",\n    key2 = \"value2\"\n};\n\nstring queryString = QueryString.Serialize(parameters);\n// Output: \"key1=value1&amp;key2=value2\"\n</code></pre>"},{"location":"reference/querystrings/#deserialize","title":"Deserialize","text":"<p>Parses a query string into an object.</p> <pre><code>string query = \"key1=value1&amp;key2=value2\";\n\nvar parameters = QueryString.Deserialize&lt;dynamic&gt;(query);\n// parameters.key1 == \"value1\"\n// parameters.key2 == \"value2\"\n</code></pre>"},{"location":"reference/querystrings/#examples-of-advanced-usage","title":"Examples of Advanced Usage","text":""},{"location":"reference/querystrings/#array-like-keys","title":"Array-like Keys","text":"<p>Supports array-like keys with <code>[]</code> notation.</p> <pre><code>string query = \"items[]=apple&amp;items[]=banana\";\n\nQueryParameters collection = QueryString.Decode(query);\n// collection[\"items\"] contains \"apple\" and \"banana\"\n\nstring encoded = QueryString.Encode(collection);\n// Output: \"items[]=apple&amp;items[]=banana\"\n</code></pre>"},{"location":"reference/querystrings/#conditional-compilation-for-webgl","title":"Conditional Compilation for WebGL","text":"<p>The utility uses <code>UnityWebRequest</code> methods for escaping/unescaping in WebGL builds to address known issues with <code>Uri.EscapeDataString</code>.</p>"},{"location":"reference/querystrings/#key-notes","title":"Key Notes","text":"<ul> <li>Platform Support: Conditional compilation ensures compatibility with WebGL and other Unity platforms.</li> <li>Custom Serialization: Use <code>JsonProperty</code> attributes to customize property names in serialized objects.</li> <li>Limitations: Nested objects and complex data structures are not supported in serialization.</li> </ul>"},{"location":"reference/request/","title":"<code>Request</code> Object","text":"<p> Runtime/Scripts/Request.cs</p> <p>The <code>Request</code> class in Uxios represents the configuration and data used to send an HTTP request. This includes the request URL, HTTP method, headers, query parameters, and any data being sent in the request body. The <code>Request</code> object is generated based on the initial configuration (<code>Config</code>), and may also be modified by interceptors and transformers before it is ultimately sent to the server.</p> <p>You don't need to create this</p> <p>This page serves as a reference to explain each field in the Request object. You don\u2019t need to create or manage  this object manually\u2014it\u2019s provided automatically in responses. The Request object is useful for  gaining insight into the request-response cycle, such as for logging or debugging purposes, where you might want  details like headers, method, or URL used in the request.</p>"},{"location":"reference/request/#fields","title":"Fields","text":""},{"location":"reference/request/#url","title":"Url","text":"<p>Type: <code>Uri</code></p> <p>Description: The target URL for the request. This is the full URI where the request will be sent, including the base URL and any relative paths provided in the configuration.</p> <p>Usage: The <code>Url</code> is typically constructed from the <code>Config</code> object, where the base URL and endpoint are combined to create a complete URI. The URL can also be modified by interceptors or query parameters added to the <code>QueryString</code> field.</p> <p>Example:</p> <pre><code>Debug.Log(\"Request URL: \" + request.Url);\n</code></pre>"},{"location":"reference/request/#method","title":"Method","text":"<p>Type: <code>HttpMethod</code></p> <p>Description: Specifies the HTTP method for the request (e.g., GET, POST, PUT, DELETE). The default value is <code>HttpMethod.Get</code> unless specified otherwise in the configuration.</p> <p>Usage: The HTTP method determines the type of action to perform on the server. For example, <code>GET</code> retrieves data, while <code>POST</code> sends new data to the server. The method is defined in the <code>Config</code> object and can be overridden before sending the request.</p> <p>Example:</p> <pre><code>if (request.Method == HttpMethod.Post)\n{\n    Debug.Log(\"This is a POST request.\");\n}\n</code></pre>"},{"location":"reference/request/#headers","title":"Headers","text":"<p>Type: <code>Headers</code></p> <p>Description: A collection of HTTP headers included in the request, stored as key-value pairs. Headers provide additional context for the server, such as authorization tokens, content types, or custom headers specific to the application.</p> <p>Usage: Headers are defined in the <code>Config</code> object and can be modified or added to by interceptors. Common headers include <code>Authorization</code> for authentication, <code>Content-Type</code> for specifying the data format, and others as needed by the server.</p> <p>Example:</p> <pre><code>if (request.Headers.ContainsKey(\"Authorization\"))\n{\n    Debug.Log(\"Authorization header present.\");\n}\n</code></pre>"},{"location":"reference/request/#querystring","title":"QueryString","text":"<p>Type: <code>QueryParameters</code></p> <p>Description: Contains the query parameters for the request, stored as a collection of key-value pairs. These parameters are appended to the URL as part of the query string, enabling dynamic data to be passed to the server.</p> <p>Usage: Query parameters are constructed from the URL and the parameters specified in <code>Config</code>. The <code>QueryString</code> is useful for filtering or customizing server responses, such as adding <code>?page=2</code> to request a specific page in a paginated response.</p> <p>Example:</p> <pre><code>Debug.Log(\"Query Parameters: \" + request.QueryString.ToString());\n</code></pre>"},{"location":"reference/request/#data","title":"Data","text":"<p>Type: <code>byte[]</code></p> <p>Description: Represents the body data to be sent with the request, typically used in <code>POST</code> or <code>PUT</code> requests. The data is serialized into a byte array format to be compatible with the HTTP request and may contain JSON, text, or binary data.</p> <p>Usage: The <code>Data</code> field is set based on the <code>Config</code> object, where the data is provided. This data is then serialized into the appropriate format (e.g., JSON) and stored as a byte array, allowing it to be sent to the server. The <code>Content-Type</code> header is set accordingly.</p> <p>Example:</p> <pre><code>if (request.Data != null)\n{\n    Debug.Log(\"Request contains data to send.\");\n}\n</code></pre>"},{"location":"reference/request/#methods","title":"Methods","text":""},{"location":"reference/request/#fromconfig","title":"FromConfig","text":"<p>Type: <code>static Request FromConfig&lt;TData&gt;(Config config) where TData : class</code></p> <p>Description: Generates a <code>Request</code> object from the provided <code>Config</code> object, which holds initial settings for the request, such as URL, headers, query parameters, data, and authentication. This method performs several steps:</p> <ul> <li>Constructs the <code>Url</code> by combining the base URL and endpoint.</li> <li>Extracts any query parameters from the URL and moves them to the <code>QueryString</code> field.</li> <li>Adds headers defined in <code>Config</code>, including any authorization headers for basic authentication.</li> <li>Serializes the request body data (if provided) into a byte array stored in <code>Data</code>.</li> </ul> <p>Usage: This static method is called to initialize a <code>Request</code> object from a configuration. The <code>Request</code> can then be further modified by interceptors or transformers before being sent.</p> <p>Example:</p> <pre><code>Request request = Request.FromConfig&lt;MyDataClass&gt;(config);\nDebug.Log(\"Generated request URL: \" + request.Url);\n</code></pre>"},{"location":"reference/request/#converttobytearray","title":"ConvertToByteArray","text":"<p>Type: <code>static (string contentType, byte[] bytes) ConvertToByteArray&lt;T&gt;(object data) where T : class</code></p> <p>Description: Converts the provided <code>data</code> object into a byte array, setting the <code>Content-Type</code> based on the data type. This method handles various data types:</p> <ul> <li><code>byte[]</code>: Directly uses the data as binary with <code>Content-Type: application/octet-stream</code>.</li> <li><code>string</code>: Converts to UTF-8 encoded text with <code>Content-Type: text/plain</code>.</li> <li>Other objects: Serializes to JSON using UTF-8 encoding with <code>Content-Type: application/json</code>.</li> </ul> <p>Usage: This helper method is called internally to prepare the request body data for sending. The <code>Data</code> field in the <code>Request</code> object is populated with the byte array returned by this method.</p> <p>Example:</p> <pre><code>var (contentType, dataBytes) = Request.ConvertToByteArray&lt;MyDataClass&gt;(myDataObject);\nDebug.Log(\"Data Content-Type: \" + contentType);\n</code></pre>"},{"location":"reference/request/#creating-and-modifying-a-request","title":"Creating and Modifying a Request","text":"<p>The <code>Request</code> object is derived from the initial <code>Config</code> settings but may be modified by interceptors before it\u2019s  sent to the server. Here\u2019s an overview:</p> <ul> <li>Interceptors: Interceptors can inspect and modify the <code>Request</code> before it is sent or the <code>Response</code> after it\u2019s   received. For example, interceptors can add custom headers, update authentication tokens, or log requests for   debugging.</li> </ul>"},{"location":"reference/request/#summary","title":"Summary","text":"<p>The <code>Request</code> object in Uxios represents the setup for an HTTP request. Each part of the request\u2014from the URL to the headers and data\u2014is carefully configured and can be modified by interceptors and transformers to meet specific requirements.</p> <ul> <li>Url: The target URL, combining base and endpoint.</li> <li>Method: Specifies the HTTP method (e.g., GET, POST).</li> <li>Headers: Custom headers for the request.</li> <li>QueryString: Query parameters appended to the URL.</li> <li>Data: The serialized body data for the request, stored as a byte array.</li> </ul> <p>The <code>Request</code> object in Uxios provides a flexible and detailed representation of an HTTP request, allowing for easy customization and modification to meet the needs of complex applications.</p>"},{"location":"reference/response/","title":"<code>Response</code> Object","text":"<p> Runtime/Scripts/Response.cs</p> <p>The <code>Response</code> class in Uxios represents the result of an HTTP request, containing detailed information about the server's response. This includes the response data, status code, headers, and additional configuration details. The <code>Response</code> object allows you to easily access both the returned data and metadata about the request, making it a core component for handling HTTP interactions in Uxios.</p> <p>You don't need to create this</p> <p>This page serves as a reference to explain each field in the Response object. You don\u2019t need to create or manage  this object manually\u2014it\u2019s provided automatically as a result of a request. The Response object is useful for  gaining insight into the request-response cycle, and is the object containing the returned <code>Data</code> from the server.</p>"},{"location":"reference/response/#fields","title":"Fields","text":""},{"location":"reference/response/#data","title":"Data","text":"<p>Type: <code>object</code></p> <p>Description: Contains the deserialized content returned by the server, such as JSON data. The <code>Data</code> field holds the core information you requested, whether it\u2019s a JSON object, array, or other format.</p> <p>Usage: The <code>Data</code> field is typically typed using a generic parameter provided to Uxios methods like <code>Get</code>, <code>Post</code>, or <code>Put</code>, or when using the <code>Resource</code> wrapper. For instance, <code>Uxios.Get&lt;Pokemon&gt;(url)</code> will type <code>Data</code> as <code>Pokemon</code>, allowing you to interact with it directly as a strongly-typed object.</p> <p>Example:</p> <pre><code>var url = new Uri(\"https://pokeapi.co/api/v2/pokemon/pikachu\");\nuxios.Get&lt;Pokemon&gt;(url)\n    .Then(response =&gt;\n    {\n        Pokemon pokemon = response.Data;\n        Debug.Log(\"Pok\u00e9mon Name: \" + pokemon.Name);\n    });\n</code></pre>"},{"location":"reference/response/#status","title":"Status","text":"<p>Type: <code>HttpStatusCode</code></p> <p>Description: Stores the HTTP status code returned by the server, indicating the success or failure of the request. Common status codes include <code>200</code> for success, <code>404</code> for not found, and <code>500</code> for server error.</p> <p>Usage: The <code>Status</code> field is useful for quickly checking the outcome of the request and can also be validated with custom logic using the <code>IsValid()</code> method (described below).</p> <p>Example:</p> <pre><code>if (response.Status == HttpStatusCode.OK)\n{\n    Debug.Log(\"Request was successful!\");\n}\n</code></pre>"},{"location":"reference/response/#headers","title":"Headers","text":"<p>Type: <code>Headers</code></p> <p>Description: Contains HTTP headers as key-value pairs, providing metadata about the response (e.g., \"Content-Type\" or \"Authorization\"). Headers are useful for accessing additional context about the response, such as content encoding, cache information, or server type.</p> <p>Usage: You can access headers individually to get more information about the response, which can be helpful for debugging or handling specific response conditions.</p> <p>Example:</p> <pre><code>string contentType = response.Headers[\"Content-Type\"];\nDebug.Log(\"Response Content Type: \" + contentType);\n</code></pre>"},{"location":"reference/response/#config","title":"Config","text":"<p>Type: <code>Config</code></p> <p>Description: Stores the configuration settings used for the request, including options such as timeout settings, custom headers, and status validation rules.</p> <p>Usage: The <code>Config</code> field lets you review the settings used for the request, which is helpful for ensuring that custom configurations (such as authorization headers or query parameters) were applied as expected.</p> <p>Example:</p> <pre><code>Debug.Log(\"Request Timeout: \" + response.Config.Timeout);\n</code></pre>"},{"location":"reference/response/#request","title":"Request","text":"<p>Type: <code>Request</code></p> <p>Description: Represents the original request that initiated the response, providing access to details about the request, such as the URL, HTTP method, and any parameters or body data.</p> <p>Usage: The <code>Request</code> field is useful if you need to inspect the original request details, especially in complex workflows where multiple requests may be involved.</p> <p>Example:</p> <pre><code>Debug.Log(\"Request URL: \" + response.Request.Url);\n</code></pre>"},{"location":"reference/response/#methods","title":"Methods","text":""},{"location":"reference/response/#isvalid","title":"IsValid()","text":"<p>Type: <code>bool</code></p> <p>Description: Validates the HTTP status code of the response based on a validation function defined in the <code>Config</code> object. This function determines if the status code falls within the expected range or matches specific criteria for a successful response.</p> <p>Usage: The <code>IsValid</code> method checks if the response status is valid according to custom validation logic, often set in the request configuration. This is helpful when working with APIs that may use different status code conventions or when you need to handle specific ranges of status codes.</p> <p>Example:</p> <pre><code>if (response.IsValid())\n{\n    Debug.Log(\"Response status is valid.\");\n}\nelse\n{\n    Debug.LogWarning(\"Response status is not valid.\");\n}\n</code></pre>"},{"location":"reference/response/#example-usage","title":"Example Usage","text":"<p>Here's an example demonstrating how to use the <code>Response</code> object fields and methods when making a GET request to retrieve a typed Pok\u00e9mon object.</p> <pre><code>using KindMen.Uxios;\nusing UnityEngine;\nusing System;\n\npublic class Example : MonoBehaviour\n{\n    private void Start()\n    {\n        var uxios = new Uxios();\n        var url = new Uri(\"https://pokeapi.co/api/v2/pokemon/pikachu\");\n\n        uxios.Get&lt;Pokemon&gt;(url)\n            .Then(response =&gt;\n            {\n                // Access the typed data directly\n                Pokemon pokemon = response.Data;\n                Debug.Log(\"Pok\u00e9mon Name: \" + pokemon.Name);\n\n                // Check the status code\n                Debug.Log(\"Status: \" + response.Status);\n\n                // Access a specific header\n                if (response.Headers.ContainsKey(\"Content-Type\"))\n                {\n                    Debug.Log(\"Content-Type: \" + response.Headers[\"Content-Type\"]);\n                }\n\n                // Validate the response status\n                if (response.IsValid())\n                {\n                    Debug.Log(\"Response is valid.\");\n                }\n                else\n                {\n                    Debug.LogWarning(\"Response status is not valid.\");\n                }\n            })\n            .Catch(error =&gt;\n            {\n                Debug.LogError(\"Request failed: \" + error.Message);\n            });\n    }\n}\n</code></pre>"},{"location":"reference/response/#key-points","title":"Key Points","text":"<ul> <li>Data: Holds the main content of the response, typed as a generic type when provided.</li> <li>Status: Stores the HTTP status code, helpful for quickly checking success or failure.</li> <li>Headers: Provides access to response headers for additional metadata.</li> <li>Config: Contains request settings, allowing review of the request\u2019s configuration.</li> <li>Request: The original request object, useful for inspecting the request details.</li> </ul> <p>The <code>Response</code> object in Uxios provides all the necessary information about an HTTP response in a structured and accessible way, making it easy to handle both data and metadata about each request in Unity.</p>"}]}